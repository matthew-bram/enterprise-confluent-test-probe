# REST API Architecture

## Table of Contents
- [Overview](#overview)
- [Module Structure](#module-structure)
- [Technology Stack](#technology-stack)
- [Architecture Patterns](#architecture-patterns)
- [Component Interaction](#component-interaction)
- [Design Principles](#design-principles)
- [Related Documentation](#related-documentation)

## Overview

The Test Probe REST API provides an HTTP interface for managing test executions in the event-driven architecture (EDA) testing framework. Built on Apache Pekko HTTP 1.1.0, the API follows hexagonal architecture principles with clear boundaries between HTTP concerns and business logic.

**Key Characteristics:**
- RESTful design with resource-oriented endpoints
- Actor-based backend for scalable test execution
- RFC 7807-inspired error responses
- Circuit breaker pattern for fail-fast behavior
- Comprehensive validation and error handling
- Production-ready operational features (health checks, structured logging)

## Module Structure

### test-probe-interfaces Module

The REST API is implemented in the `test-probe-interfaces` module, which provides all client-facing interfaces (REST, CLI, gRPC).

**Directory Structure:**
```
test-probe-interfaces/
├── src/main/scala/io/distia/probe/interfaces/
│   ├── rest/
│   │   ├── RestRoutes.scala                 # Main HTTP routes (256 lines)
│   │   ├── RestExceptionHandler.scala       # Exception → HTTP status mapping
│   │   ├── RestRejectionHandler.scala       # Rejection → HTTP status mapping
│   │   ├── RestErrorResponse.scala          # RFC 7807-inspired error model
│   │   └── RestValidation.scala             # Request validation logic
│   ├── models/rest/
│   │   ├── RestModels.scala                 # REST DTOs (kebab-case)
│   │   └── RestModelConversions.scala       # Anti-corruption layer
│   ├── config/
│   │   └── InterfacesConfig.scala           # Type-safe configuration
│   └── bootstrap/
│       └── InterfacesBootstrap.scala        # HTTP server lifecycle
├── src/main/resources/
│   ├── reference.conf                       # HOCON configuration
│   └── openapi.yaml                         # OpenAPI 3.0 specification
└── src/test/scala/io/distia/probe/interfaces/
    └── rest/
        ├── RestRoutesHealthCheckSpec.scala  # Health check tests
        ├── RestRoutesErrorHandlingSpec.scala # Error path tests
        ├── RestValidationSpec.scala          # Validation tests
        └── RestErrorResponseSpec.scala       # Error factory tests
```

**Implementation Metrics:**
- Core routes: 256 lines (RestRoutes.scala)
- Exception handling: 130 lines (RestExceptionHandler.scala)
- Rejection handling: 99 lines (RestRejectionHandler.scala)
- Error model: 97 lines (RestErrorResponse.scala)
- Validation: 91 lines (RestValidation.scala)
- Configuration: 124 lines (InterfacesConfig.scala)
- OpenAPI spec: 700+ lines (complete API documentation)
- Test coverage: 186 tests (122 existing + 64 new)

## Technology Stack

### Apache Pekko HTTP 1.1.0

**Why Pekko HTTP?**
- Apache 2.0 license (not BSL like Akka 2.7+)
- Active development under Apache Software Foundation
- Production-proven (fork of Akka HTTP)
- Seamless integration with Pekko Typed Actors
- Excellent Scala 3 support

**Key Features Used:**
- Route DSL with directives
- Custom exception and rejection handlers
- Request/response marshalling (Spray JSON)
- Graceful shutdown support
- Backpressure for concurrent requests

**Dependencies:**
```scala
// See test-probe-interfaces/pom.xml
"org.apache.pekko" %% "pekko-http" % "1.1.0"
"org.apache.pekko" %% "pekko-http-spray-json" % "1.1.0"
"org.apache.pekko" %% "pekko-actor-typed" % "1.1.2"
```

### Spray JSON

**JSON Serialization Strategy:**
- Spray JSON for HTTP boundary (REST DTOs)
- Circe for internal actor messages (core module)
- Clear separation prevents serialization conflicts

**Format Pattern:**
```scala
// Example from RestModels.scala
case class RestStartTestRequest(
  `test-id`: UUID,
  `block-storage-path`: String,
  `test-type`: Option[String]
)

object RestStartTestRequest {
  implicit val format: RootJsonFormat[RestStartTestRequest] =
    jsonFormat3(RestStartTestRequest.apply)
}
```

### Pekko Typed Actors

**Actor-Based Backend:**
- GuardianActor: Root supervisor, error kernel pattern
- QueueActor: FIFO test queue management
- TestExecutionActor: 7-state FSM for test lifecycle
- 5 child actors: BlockStorage, Vault, Cucumber, Kafka Producer/Consumer

**Communication Pattern:**
```scala
// ServiceInterfaceFunctions wraps actor asks with circuit breaker
def initializeTest(): Future[InitializeTestResponse]
def startTest(testId: UUID, bucket: String, testType: Option[String]): Future[StartTestResponse]
def getStatus(testId: UUID): Future[TestStatusResponse]
def getQueueStatus(testId: Option[UUID]): Future[QueueStatusResponse]
def cancelTest(testId: UUID): Future[TestCancelledResponse]
```

## Architecture Patterns

### Hexagonal Architecture (Ports and Adapters)

**Clean Boundaries:**
```
┌─────────────────────────────────────────────────────────┐
│ test-probe-interfaces (Adapter Layer)                  │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ RestRoutes (HTTP Adapter)                           │ │
│ │ - HTTP request → REST DTO                           │ │
│ │ - Validation                                        │ │
│ │ - Exception/rejection handling                      │ │
│ │ - HTTP response ← REST DTO                          │ │
│ └─────────────────────────────────────────────────────┘ │
│                          ↓                              │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ RestModelConversions (Anti-Corruption Layer)        │ │
│ │ - REST DTO ↔ Core Domain Model                     │ │
│ │ - kebab-case ↔ camelCase                           │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ test-probe-core (Port - Business Logic)                │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ ServiceInterfaceFunctions (Port Interface)          │ │
│ │ - Protocol-agnostic business operations             │ │
│ │ - Circuit breaker integration                       │ │
│ │ - Actor communication                               │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

**Benefits:**
- Core business logic independent of HTTP concerns
- Easy to add new interfaces (CLI, gRPC) without touching core
- Testable in isolation (mock ServiceInterfaceFunctions)
- Clear dependency direction (interfaces → core, never reverse)

### Anti-Corruption Layer

**Purpose:** Prevent REST concerns from leaking into core domain models.

**Implementation:**
```scala
// File: RestModelConversions.scala (80 lines)

// REST → Core (inbound requests)
def toCore(req: RestStartTestRequest): (UUID, String, Option[String]) =
  (req.`test-id`, req.`block-storage-path`, req.`test-type`)

// Core → REST (outbound responses)
def toRest(resp: StartTestResponse): RestStartTestResponse =
  RestStartTestResponse(resp.testId, resp.accepted, resp.testType, resp.message)
```

**Naming Conventions:**
- REST DTOs: kebab-case (HTTP/JSON standard)
- Core models: camelCase (Scala standard)
- Conversion at boundary only

### Error Kernel Pattern

**Pattern:** Let actors crash, supervisor handles recovery.

**RestRoutes Role:**
- Does NOT catch actor failures
- Delegates to ServiceInterfaceFunctions
- Maps typed exceptions to HTTP status codes
- Logs errors with context

**Flow:**
```
RestRoutes → ServiceInterfaceFunctions → Circuit Breaker → Actor Ask
                                              ↓
                              Exception (timeout, unavailable)
                                              ↓
                    RestExceptionHandler → HTTP 503/504
```

**Why This Works:**
- Actors recover independently via supervisor
- Circuit breaker fails fast when actors unhealthy
- HTTP clients get meaningful error responses
- System remains stable under load

### Circuit Breaker Pattern

**Integration:**
```scala
// Implemented in ServiceInterfaceFunctions (core module)
val circuitBreaker = CircuitBreaker(
  maxFailures = 5,
  callTimeout = 25.seconds,
  resetTimeout = 30.seconds
)

def initializeTest(): Future[InitializeTestResponse] =
  circuitBreaker.withCircuitBreaker {
    guardian.ask[InitializeTestResponse](...)
  }
```

**States:**
1. Closed: Normal operation, requests pass through
2. Open: 5 failures → fail fast, throw ServiceUnavailableException
3. Half-Open: After 30s, allow 1 request to test recovery

**REST Response:**
```json
// 503 Service Unavailable when circuit breaker open
{
  "error": "service_unavailable",
  "message": "Circuit breaker open - too many failures",
  "retryAfter": "30s",
  "timestamp": 1634567890123
}
```

### Validation Pattern

**Early Validation:** Validate requests BEFORE actor communication.

**Benefits:**
- Fail fast for invalid input
- Reduce actor load (no asks for bad requests)
- Better error messages (field-specific)
- Composable validators (Either[String, Unit])

**Example:**
```scala
// File: RestValidation.scala (91 lines)

def validateStartRequest(req: RestStartTestRequest): Either[String, Unit] = {
  val path = req.`block-storage-path`.trim

  if (path.isEmpty) {
    Left("block-storage-path cannot be empty")
  } else if (!path.startsWith("s3://")) {
    Left("block-storage-path must be a valid S3 path (s3://bucket/...)")
  } else {
    req.`test-type` match {
      case Some(testType) if testType.trim.isEmpty =>
        Left("test-type cannot be empty string")
      case _ =>
        Right(())
    }
  }
}
```

**Usage in Route:**
```scala
// POST /api/v1/test/start
RestValidation.validateStartRequest(request) match {
  case Left(errorMessage) =>
    complete(StatusCodes.BadRequest,
      RestErrorResponse.validationError("Request validation failed", errorMessage))

  case Right(_) =>
    // Proceed with actor communication
    onComplete(functions.startTest(...)) { ... }
}
```

## Component Interaction

### Request Flow

```
1. Client → HTTP Request
        ↓
2. Pekko HTTP → Route Matching
        ↓
3. RestRoutes → Request Validation (RestValidation)
        ↓
4. RestRoutes → DTO Conversion (RestModelConversions)
        ↓
5. ServiceInterfaceFunctions → Circuit Breaker Check
        ↓
6. Circuit Breaker → Actor Ask (with timeout)
        ↓
7. Actor → Process Command → Return Response
        ↓
8. ServiceInterfaceFunctions → Wrap Exception (if failed)
        ↓
9. RestRoutes → Map Exception to HTTP Status
        ↓
10. RestRoutes → Convert Response (RestModelConversions)
        ↓
11. Pekko HTTP → Serialize JSON (Spray JSON)
        ↓
12. Client ← HTTP Response
```

### Error Flow

```
1. Exception in Actor or Circuit Breaker
        ↓
2. ServiceInterfaceFunctions → Typed Exception
   - ServiceTimeoutException
   - ServiceUnavailableException
   - IllegalArgumentException
        ↓
3. RestExceptionHandler → HTTP Status Code
   - 504 Gateway Timeout
   - 503 Service Unavailable
   - 400 Bad Request
        ↓
4. RestErrorResponse Factory → Error JSON
        ↓
5. Client ← HTTP Error Response
```

## Design Principles

### 1. Fail Fast

**Validation:** Validate input immediately, before actor communication.

**Circuit Breaker:** Fail fast when system unhealthy (don't queue requests).

**Timeouts:** Hierarchical timeouts ensure requests don't hang:
- Ask timeout: 25s (actor must respond)
- HTTP timeout: 30s (client must receive response)
- Circuit breaker timeout: 25s (matches ask timeout)

### 2. Be Liberal in What You Accept, Conservative in What You Send

**Accept:**
- Optional fields (test-type)
- Flexible query parameters
- Case-insensitive UUIDs

**Send:**
- Consistent error format (RFC 7807-inspired)
- Clear error messages (no internal details)
- Structured responses (predictable schema)

### 3. Clean Separation of Concerns

**Layers:**
- HTTP: RestRoutes, handlers (interfaces module)
- Validation: RestValidation (interfaces module)
- Business Logic: ServiceInterfaceFunctions, actors (core module)
- Conversion: RestModelConversions (anti-corruption layer)

**Each layer has ONE responsibility.**

### 4. Testability

**Unit Tests:** All components testable in isolation
- RestValidation: Pure functions, easy to test
- RestErrorResponse: Factory methods, easy to verify
- RestRoutes: Mock ServiceInterfaceFunctions

**Test Metrics:**
- 186 total tests (122 existing + 64 new)
- All endpoints tested (success + error paths)
- All validation rules tested
- All error factory methods tested
- Zero failures, zero errors

### 5. Observability

**Structured Logging:**
```scala
// All endpoints log:
logger.info("POST /test/start testId=$testId bucket=$bucket")
logger.info("Test started: testId=$testId accepted=${response.accepted}")
logger.error("Timeout starting test testId=$testId", ex)
```

**Health Check:** `/api/v1/health` verifies actor system responsiveness.

**Error Context:** Errors logged with full context for debugging.

## Related Documentation

**Architecture:**
- [REST Error Handling](03.1-rest-error-handling.md) - Exception and rejection handling
- [REST API Endpoints](03.1-rest-api-endpoints.md) - Endpoint reference
- [REST Timeouts & Resilience](03.1-rest-timeouts-resilience.md) - Configuration guide
- [OpenAPI Specification](../../../../api/rest-api-openapi-specification.md) - API spec usage

**ADRs:**
- [ADR-REST-001: Error Handling Strategy](../../../adr/ADR-REST-001-ERROR-HANDLING-STRATEGY.md)
- [ADR-REST-002: Validation Pattern](../../../adr/ADR-REST-002-VALIDATION-PATTERN.md)
- [ADR-REST-003: Pekko HTTP Technology](../../../adr/ADR-REST-003-PEKKO-HTTP-TECHNOLOGY.md)

**Diagrams:**
- [REST Request Flow](../../../diagrams/03-apis/rest-api-request-flow.mermaid)
- [Error Handling Flow](../../../diagrams/03-apis/rest-error-handling-flow.mermaid)
- [Module Dependencies](../../../diagrams/03-apis/rest-module-dependencies.mermaid)
- [Circuit Breaker Integration](../../../diagrams/03-apis/rest-circuit-breaker.mermaid)

**Implementation Files:**
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/rest/RestRoutes.scala` (256 lines)
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/rest/RestExceptionHandler.scala` (130 lines)
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/rest/RestRejectionHandler.scala` (99 lines)
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/rest/RestErrorResponse.scala` (97 lines)
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/rest/RestValidation.scala` (91 lines)
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/config/InterfacesConfig.scala` (124 lines)
- `/test-probe-interfaces/src/main/resources/openapi.yaml` (700+ lines)

---

**Last Updated:** 2025-10-19
**Status:** Production-Ready
**Module:** test-probe-interfaces
**Technology:** Apache Pekko HTTP 1.1.0, Scala 3.3.6
