# REST API Error Handling Architecture

## Table of Contents
- [Overview](#overview)
- [Error Handling Strategy](#error-handling-strategy)
- [Exception Handling](#exception-handling)
- [Rejection Handling](#rejection-handling)
- [Error Response Format](#error-response-format)
- [Circuit Breaker Integration](#circuit-breaker-integration)
- [Logging Strategy](#logging-strategy)
- [Best Practices](#best-practices)
- [Related Documentation](#related-documentation)

## Overview

The Test Probe REST API implements comprehensive error handling that maps all failure modes to appropriate HTTP status codes with structured error responses. The architecture follows RFC 7807-inspired patterns for consistent, client-friendly error responses.

**Core Principles:**
1. **Never expose internal details** - Security-first error messages
2. **Map typed exceptions** - ServiceTimeoutException → 504, etc.
3. **Fail fast** - Validate early, circuit breaker prevents cascading failures
4. **Structured responses** - Consistent error format across all endpoints
5. **Full observability** - Log everything with context for debugging

## Error Handling Strategy

### Exception Handling vs Rejection Handling

**Pekko HTTP provides two error mechanisms:**

1. **Exceptions** - Runtime failures (timeouts, actor errors, unexpected exceptions)
   - Handled by: `RestExceptionHandler`
   - Response: Server errors (5xx) or client errors (4xx)
   - Examples: ServiceTimeoutException, IllegalArgumentException

2. **Rejections** - Request doesn't match routes (wrong method, missing endpoint)
   - Handled by: `RestRejectionHandler`
   - Response: Client errors (4xx) with guidance
   - Examples: MethodRejection, MalformedRequestContentRejection

**Both return RFC 7807-inspired RestErrorResponse.**

### HTTP Status Code Mapping

**Client Errors (4xx):**
```
400 Bad Request              ← IllegalArgumentException, ValidationRejection
404 Not Found                ← NoSuchElementException, handleNotFound
405 Method Not Allowed       ← MethodRejection (GET to POST endpoint)
415 Unsupported Media Type   ← UnsupportedRequestContentTypeRejection
```

**Server Errors (5xx):**
```
500 Internal Server Error    ← Unexpected exceptions
503 Service Unavailable      ← ServiceUnavailableException, TimeoutException
504 Gateway Timeout          ← ServiceTimeoutException, AskTimeoutException
```

**Success Codes:**
```
200 OK                       ← GET requests (status, queue status, cancel)
201 Created                  ← POST /initialize (new test created)
202 Accepted                 ← POST /start (test queued for execution)
```

## Exception Handling

### Implementation: RestExceptionHandler

**File:** `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestExceptionHandler.scala` (130 lines)

**Pattern:**
```scala
def handler: ExceptionHandler = ExceptionHandler {

  // Client Errors (4xx)
  case ex: IllegalArgumentException =>
    logger.warn(s"Bad request: ${ex.getMessage}")
    complete(StatusCodes.BadRequest, badRequest(s"Invalid request: ${ex.getMessage}"))

  case ex: DeserializationException =>
    logger.warn(s"Invalid JSON: ${ex.getMessage}")
    complete(StatusCodes.BadRequest, badRequest(s"Invalid JSON format: ${ex.getMessage}"))

  case ex: NoSuchElementException =>
    logger.warn(s"Resource not found: ${ex.getMessage}")
    complete(StatusCodes.NotFound, notFound(s"Requested resource not found: ${ex.getMessage}"))

  // Server Errors (5xx)
  case ex: ServiceTimeoutException =>
    logger.error(s"Service timeout: ${ex.getMessage}", ex)
    complete(StatusCodes.GatewayTimeout, actorTimeout("Actor system did not respond in time", Some(ex.getMessage)))

  case ex: ServiceUnavailableException =>
    logger.warn(s"Service unavailable: ${ex.getMessage}")
    complete(StatusCodes.ServiceUnavailable, serviceUnavailable(ex.getMessage, "30s"))

  case ex: ActorSystemNotReadyException =>
    logger.warn(s"Actor system not ready: ${ex.getMessage}")
    complete(StatusCodes.ServiceUnavailable, notReady(ex.getMessage))

  case ex: AskTimeoutException =>
    logger.error(s"Unwrapped ask timeout: ${ex.getMessage}", ex)
    complete(StatusCodes.GatewayTimeout, timeout(s"Request timed out: ${ex.getMessage}"))

  case ex: TimeoutException =>
    logger.error(s"Request timeout: ${ex.getMessage}", ex)
    complete(StatusCodes.ServiceUnavailable, timeout("Request timed out - service may be temporarily unavailable"))

  // Catch-all
  case ex: Exception =>
    logger.error(s"Unexpected server error: ${ex.getClass.getSimpleName} - ${ex.getMessage}", ex)
    complete(StatusCodes.InternalServerError, internalServerError("An unexpected error occurred. Please contact support if this persists."))
}
```

### Exception Types and Meanings

#### ServiceTimeoutException → 504 Gateway Timeout

**When:** Actor does not respond within ask timeout (25 seconds).

**Cause:**
- Actor processing takes too long
- Actor mailbox backlog (queue depth)
- System under heavy load

**Response:**
```json
{
  "error": "actor_timeout",
  "message": "Actor system did not respond in time",
  "details": "Ask timeout after 25000 milliseconds",
  "timestamp": 1634567890123
}
```

**Client Action:** Retry after brief delay (exponential backoff).

#### ServiceUnavailableException → 503 Service Unavailable

**When:** Circuit breaker is open (too many failures).

**Cause:**
- 5+ consecutive actor failures
- System unhealthy (actor crashes, deadlocks)
- Temporary outage

**Response:**
```json
{
  "error": "service_unavailable",
  "message": "Circuit breaker open - too many failures",
  "retryAfter": "30s",
  "timestamp": 1634567890123
}
```

**Client Action:** Wait 30s (retryAfter), then retry.

**Circuit Breaker Auto-Recovery:**
- After 30s: Circuit breaker moves to Half-Open
- First request succeeds: Circuit closes, normal operation resumes
- First request fails: Circuit reopens for another 30s

#### IllegalArgumentException → 400 Bad Request

**When:** Business logic validation fails.

**Cause:**
- Invalid test ID (not found)
- Invalid state transition (e.g., start already-started test)
- Invalid business rule violation

**Response:**
```json
{
  "error": "bad_request",
  "message": "Invalid request: Test ID abc-123 not found",
  "timestamp": 1634567890123
}
```

**Client Action:** Fix input, don't retry with same data.

#### DeserializationException → 400 Bad Request

**When:** JSON parsing fails.

**Cause:**
- Malformed JSON
- Missing required field
- Type mismatch (string instead of UUID)

**Response:**
```json
{
  "error": "bad_request",
  "message": "Invalid JSON format: Expected UUID for field 'test-id'",
  "timestamp": 1634567890123
}
```

**Client Action:** Fix JSON schema, don't retry.

#### NoSuchElementException → 404 Not Found

**When:** Resource lookup fails.

**Cause:**
- Test ID not in queue
- Resource deleted/expired

**Response:**
```json
{
  "error": "not_found",
  "message": "Requested resource not found: No test with ID abc-123",
  "timestamp": 1634567890123
}
```

**Client Action:** Don't retry, resource doesn't exist.

#### Exception (catch-all) → 500 Internal Server Error

**When:** Unexpected error (programming bug, etc.).

**Cause:**
- NullPointerException
- Database connection failure
- Unexpected runtime error

**Response:**
```json
{
  "error": "internal_server_error",
  "message": "An unexpected error occurred. Please contact support if this persists.",
  "timestamp": 1634567890123
}
```

**Security:** Never expose exception details (class name, stack trace) to client.

**Logging:** Full exception logged server-side with stack trace.

**Client Action:** Retry with backoff, escalate if persists.

## Rejection Handling

### Implementation: RestRejectionHandler

**File:** `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestRejectionHandler.scala` (99 lines)

**Pattern:**
```scala
def handler: RejectionHandler = RejectionHandler.newBuilder()

  .handle {
    case MalformedRequestContentRejection(message, _) =>
      logger.warn(s"Malformed request: $message")
      complete(StatusCodes.BadRequest, badRequest(s"Invalid request body: $message"))
  }

  .handle {
    case UnsupportedRequestContentTypeRejection(supported) =>
      logger.warn(s"Unsupported Content-Type, expected: $supported")
      complete(StatusCodes.UnsupportedMediaType, unsupportedMediaType(s"Content-Type must be: ${supported.mkString(", ")}"))
  }

  .handle {
    case ValidationRejection(message, _) =>
      logger.warn(s"Validation failed: $message")
      complete(StatusCodes.BadRequest, validationError("Request validation failed", message))
  }

  .handle {
    case MissingQueryParamRejection(paramName) =>
      logger.warn(s"Missing query parameter: $paramName")
      complete(StatusCodes.BadRequest, badRequest(s"Required query parameter missing: $paramName"))
  }

  .handleAll[MethodRejection] { rejections =>
    val supportedMethods = rejections.map(_.supported.name).mkString(", ")
    logger.warn(s"Method not allowed, supported: $supportedMethods")
    complete(StatusCodes.MethodNotAllowed, methodNotAllowed(s"Supported methods: $supportedMethods"))
  }

  .handleNotFound {
    logger.warn("Endpoint not found")
    complete(StatusCodes.NotFound, notFound("The requested endpoint does not exist"))
  }

  .result()
```

### Rejection Types and Meanings

#### MalformedRequestContentRejection → 400 Bad Request

**When:** JSON is invalid (syntax error, missing brace, etc.).

**Example Request:**
```json
{ "test-id": "abc",  // ← Missing closing brace
```

**Response:**
```json
{
  "error": "bad_request",
  "message": "Invalid request body: Unexpected end of JSON input",
  "timestamp": 1634567890123
}
```

#### UnsupportedRequestContentTypeRejection → 415 Unsupported Media Type

**When:** Wrong Content-Type header.

**Example Request:**
```
POST /api/v1/test/start
Content-Type: text/plain  ← Should be application/json
```

**Response:**
```json
{
  "error": "unsupported_media_type",
  "message": "Content-Type must be: application/json",
  "timestamp": 1634567890123
}
```

#### ValidationRejection → 400 Bad Request

**When:** Path parameter fails validation (e.g., invalid UUID).

**Example Request:**
```
GET /api/v1/test/not-a-uuid/status  ← Invalid UUID format
```

**Response:**
```json
{
  "error": "validation_error",
  "message": "Request validation failed",
  "details": "Invalid UUID format",
  "timestamp": 1634567890123
}
```

#### MissingQueryParamRejection → 400 Bad Request

**When:** Required query parameter is missing.

**Note:** Currently, all query parameters are optional (testId on /queue/status).

**Example (if required):**
```
GET /api/v1/queue/status  ← Missing required ?testId=...
```

**Response:**
```json
{
  "error": "bad_request",
  "message": "Required query parameter missing: testId",
  "timestamp": 1634567890123
}
```

#### MethodRejection → 405 Method Not Allowed

**When:** Wrong HTTP method for endpoint.

**Example Request:**
```
GET /api/v1/test/start  ← Should be POST
```

**Response:**
```json
{
  "error": "method_not_allowed",
  "message": "Supported methods: POST",
  "timestamp": 1634567890123
}
```

**HTTP Header:**
```
Allow: POST
```

#### handleNotFound → 404 Not Found

**When:** Endpoint doesn't exist.

**Example Request:**
```
GET /api/v1/nonexistent
```

**Response:**
```json
{
  "error": "not_found",
  "message": "The requested endpoint does not exist",
  "timestamp": 1634567890123
}
```

## Error Response Format

### RFC 7807-Inspired Structure

**File:** `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestErrorResponse.scala` (97 lines)

**Model:**
```scala
case class RestErrorResponse(
  error: String,              // Machine-readable error code
  message: String,            // Human-readable description
  details: Option[String] = None,     // Optional structured details
  retryAfter: Option[String] = None,  // Optional retry delay (for 503)
  timestamp: Long = System.currentTimeMillis()  // When error occurred
)
```

**Design Rationale:**
- **error:** Machine-readable, consistent (for client error handling logic)
- **message:** Human-readable, contextual (for user display)
- **details:** Structured details (field validation errors, additional context)
- **retryAfter:** Retry guidance for 503 responses (circuit breaker reset time)
- **timestamp:** Epoch milliseconds (for correlation with logs)

### Factory Methods

**All error responses created via factory methods:**

```scala
// 400 Bad Request - Generic
def badRequest(message: String, details: Option[String] = None): RestErrorResponse

// 400 Bad Request - Validation error with field details
def validationError(message: String, details: String): RestErrorResponse

// 404 Not Found
def notFound(message: String): RestErrorResponse

// 405 Method Not Allowed
def methodNotAllowed(message: String): RestErrorResponse

// 415 Unsupported Media Type
def unsupportedMediaType(message: String): RestErrorResponse

// 500 Internal Server Error
def internalServerError(message: String): RestErrorResponse

// 503 Service Unavailable (circuit breaker open)
def serviceUnavailable(message: String, retryAfter: String = "30s"): RestErrorResponse

// 503 Service Unavailable (actor system not ready)
def notReady(message: String): RestErrorResponse  // retryAfter = "5s"

// 504 Gateway Timeout - Generic timeout
def timeout(message: String): RestErrorResponse

// 504 Gateway Timeout - Actor-specific timeout
def actorTimeout(message: String, details: Option[String] = None): RestErrorResponse
```

**Benefits:**
- Consistent error code naming
- Type-safe construction
- Easy to test
- Clear intent

### Error Code Reference

| Error Code | HTTP Status | Meaning | Retry? |
|-----------|-------------|---------|--------|
| `bad_request` | 400 | Invalid input | No - fix input |
| `validation_error` | 400 | Field validation failed | No - fix field |
| `not_found` | 404 | Resource doesn't exist | No - resource missing |
| `method_not_allowed` | 405 | Wrong HTTP method | No - use correct method |
| `unsupported_media_type` | 415 | Wrong Content-Type | No - use application/json |
| `internal_server_error` | 500 | Unexpected server error | Yes - with backoff |
| `service_unavailable` | 503 | Circuit breaker open | Yes - after retryAfter |
| `not_ready` | 503 | System initializing | Yes - after 5s |
| `timeout` | 504 | Request timeout | Yes - with backoff |
| `actor_timeout` | 504 | Actor ask timeout | Yes - with backoff |

## Circuit Breaker Integration

### Fail-Fast Pattern

**Flow:**
```
Client Request
    ↓
RestRoutes
    ↓
ServiceInterfaceFunctions
    ↓
Circuit Breaker (check state)
    ↓
    ├─ Closed: Allow request → Actor Ask
    │
    ├─ Open: Fail fast → throw ServiceUnavailableException
    │                         ↓
    │                   RestExceptionHandler
    │                         ↓
    │                   503 Service Unavailable (retryAfter: "30s")
    │
    └─ Half-Open: Allow 1 request → Actor Ask
                       ↓
                   Success: Close circuit
                   Failure: Reopen circuit
```

### Configuration

**File:** `/test-probe-interfaces/src/main/resources/reference.conf`

```hocon
test-probe.interfaces.rest {
  circuit-breaker-max-failures = 5      # Open after 5 failures
  circuit-breaker-call-timeout = 25s    # Must equal ask-timeout
  circuit-breaker-reset-timeout = 30s   # Half-open after 30s
}
```

**Timeout Alignment:**
- `circuit-breaker-call-timeout` MUST equal `ask-timeout` (validated in InterfacesConfig)
- Ensures consistent timeout behavior across all actor asks

### Retry-After Semantics

**503 Response with Retry-After:**
```json
{
  "error": "service_unavailable",
  "message": "Circuit breaker open - too many failures",
  "retryAfter": "30s",
  "timestamp": 1634567890123
}
```

**Client Behavior:**
1. Parse `retryAfter` value (30s)
2. Wait 30 seconds
3. Retry request
4. If still 503: Wait longer (exponential backoff)
5. If 200: Circuit closed, normal operation resumed

**Auto-Recovery:**
- Circuit breaker automatically moves to Half-Open after 30s
- No manual intervention required
- First successful request closes circuit

## Logging Strategy

### Structured Logging

**Pattern:**
```scala
// Request received (INFO)
logger.info(s"POST /test/start testId=$testId bucket=$bucket")

// Success (INFO)
logger.info(s"Test started: testId=$testId accepted=${response.accepted}")

// Client error (WARN)
logger.warn(s"Validation failed: $errorMessage")

// Server error (ERROR with exception)
logger.error(s"Timeout starting test testId=$testId", ex)
```

### Log Levels

**INFO:** Normal operation
- Request received (with key parameters)
- Successful response (with result summary)

**WARN:** Client errors or recoverable issues
- Validation failures
- 400/404/405/415 responses
- Circuit breaker open (expected during outages)

**ERROR:** Server errors or unexpected failures
- 500/504 responses
- Unexpected exceptions
- Actor timeout (system performance issue)

### Context in Logs

**Always include:**
- Endpoint (POST /test/start)
- Request ID (testId)
- Key parameters (bucket, testType)
- Exception stack trace (for errors)

**Example:**
```
2025-10-19 10:30:45 INFO  RestRoutes - POST /test/start testId=123e4567-e89b-12d3-a456-426614174000 bucket=s3://test-bucket/features/
2025-10-19 10:30:45 INFO  RestRoutes - Test started: testId=123e4567-e89b-12d3-a456-426614174000 accepted=true
```

**Error Example:**
```
2025-10-19 10:30:50 ERROR RestRoutes - Timeout starting test testId=123e4567-e89b-12d3-a456-426614174000
io.distia.probe.core.models.ServiceTimeoutException: Ask timeout after 25000 milliseconds
  at io.distia.probe.core.builder.ServiceInterfaceFunctionsFactory.wrapAsk(...)
  at io.distia.probe.core.builder.ServiceInterfaceFunctionsFactory.startTest(...)
  ...
```

## Best Practices

### 1. Never Expose Internal Details

**BAD:**
```json
{
  "error": "NullPointerException",
  "message": "at io.distia.probe.core.actors.TestExecutionActor.onStart(TestExecutionActor.scala:123)"
}
```

**GOOD:**
```json
{
  "error": "internal_server_error",
  "message": "An unexpected error occurred. Please contact support if this persists."
}
```

**Reason:** Security (don't expose implementation details to attackers).

### 2. Always Log Full Context

**BAD:**
```scala
logger.error("Error starting test", ex)  // Missing testId!
```

**GOOD:**
```scala
logger.error(s"Error starting test testId=$testId bucket=$bucket", ex)
```

**Reason:** Debugging requires full context (which test? which bucket?).

### 3. Use Factory Methods for Errors

**BAD:**
```scala
RestErrorResponse("timeout", "Request timed out")  // Missing timestamp, inconsistent error code
```

**GOOD:**
```scala
RestErrorResponse.timeout("Request timed out")  // Consistent, includes timestamp
```

**Reason:** Consistency, type safety, easier to maintain.

### 4. Validate Early, Fail Fast

**BAD:**
```scala
// Send to actor, then validate
onComplete(functions.startTest(testId, bucket, testType)) {
  case Failure(ex: IllegalArgumentException) => ...  // Too late!
}
```

**GOOD:**
```scala
// Validate BEFORE actor communication
RestValidation.validateStartRequest(request) match {
  case Left(errorMessage) =>
    complete(StatusCodes.BadRequest, RestErrorResponse.validationError(...))

  case Right(_) =>
    onComplete(functions.startTest(...)) { ... }
}
```

**Reason:** Don't waste actor resources on invalid input.

### 5. Distinguish Retriable vs Non-Retriable Errors

**Non-Retriable (4xx):**
- 400 Bad Request: Fix input, don't retry
- 404 Not Found: Resource doesn't exist, don't retry
- 405 Method Not Allowed: Wrong method, don't retry
- 415 Unsupported Media Type: Wrong Content-Type, don't retry

**Retriable (5xx):**
- 500 Internal Server Error: Retry with exponential backoff
- 503 Service Unavailable: Retry after retryAfter delay
- 504 Gateway Timeout: Retry with exponential backoff

**Client Logic:**
```typescript
if (response.status >= 400 && response.status < 500) {
  // Client error - don't retry, fix input
  throw new Error(`Client error: ${response.error.message}`);
}

if (response.status >= 500) {
  // Server error - retry with backoff
  if (response.error.retryAfter) {
    await sleep(parseRetryAfter(response.error.retryAfter));
  } else {
    await sleep(exponentialBackoff(attempt));
  }
  return retry();
}
```

## Related Documentation

**Architecture:**
- [REST API Architecture](03.1-rest-api-architecture.md) - Overall design
- [REST API Endpoints](03.1-rest-api-endpoints.md) - Endpoint reference
- [REST Timeouts & Resilience](03.1-rest-timeouts-resilience.md) - Configuration guide

**ADRs:**
- [ADR-REST-001: Error Handling Strategy](adr/ADR-REST-001-ERROR-HANDLING-STRATEGY.md)
- [ADR-REST-002: Validation Pattern](adr/ADR-REST-002-VALIDATION-PATTERN.md)

**Diagrams:**
- [Error Handling Flow](diagrams/rest-error-handling-flow.mermaid)
- [Circuit Breaker Integration](diagrams/rest-circuit-breaker.mermaid)

**Implementation Files:**
- `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestExceptionHandler.scala` (130 lines)
- `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestRejectionHandler.scala` (99 lines)
- `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestErrorResponse.scala` (97 lines)
- `/test-probe-interfaces/src/main/scala/com/company/probe/interfaces/rest/RestValidation.scala` (91 lines)

**Tests:**
- `/test-probe-interfaces/src/test/scala/com/company/probe/interfaces/rest/RestRoutesErrorHandlingSpec.scala` (704 lines, 27 tests)
- `/test-probe-interfaces/src/test/scala/com/company/probe/interfaces/rest/RestValidationSpec.scala` (247 lines, 19 tests)
- `/test-probe-interfaces/src/test/scala/com/company/probe/interfaces/rest/RestErrorResponseSpec.scala` (360 lines, 18 tests)

---

**Last Updated:** 2025-10-19
**Status:** Production-Ready
**Module:** test-probe-interfaces
**Coverage:** 64 tests covering all error paths
