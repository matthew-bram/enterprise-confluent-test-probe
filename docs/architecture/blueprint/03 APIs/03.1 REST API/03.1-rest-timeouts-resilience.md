# REST API Timeouts and Resilience Configuration

## Table of Contents
- [Overview](#overview)
- [Timeout Hierarchy](#timeout-hierarchy)
- [Configuration Reference](#configuration-reference)
- [Circuit Breaker Configuration](#circuit-breaker-configuration)
- [Graceful Shutdown](#graceful-shutdown)
- [HTTP Server Limits](#http-server-limits)
- [Environment Variable Overrides](#environment-variable-overrides)
- [Production Tuning Guidelines](#production-tuning-guidelines)
- [Troubleshooting](#troubleshooting)
- [Related Documentation](#related-documentation)

## Overview

The Test Probe REST API implements a comprehensive timeout and resilience strategy to ensure predictable behavior under load and failure conditions. The configuration follows a hierarchical timeout model with circuit breaker integration for fail-fast behavior.

**Key Resilience Patterns:**
1. **Hierarchical Timeouts** - Timeouts trigger in order (ask < HTTP < overall)
2. **Circuit Breaker** - Fail fast when system unhealthy (prevent cascading failures)
3. **Graceful Shutdown** - Coordinated termination of in-flight requests
4. **Backpressure** - Limit concurrent requests to prevent overload
5. **Validation** - Type-safe configuration with compile-time guarantees

## Timeout Hierarchy

### Why Hierarchical Timeouts?

**Problem:** Without a hierarchy, clients can't distinguish between different timeout causes:
- Did the actor timeout?
- Did the HTTP request timeout?
- Did the entire operation timeout?

**Solution:** Layer timeouts so earlier timeouts trigger first:

```
┌───────────────────────────────────────────────────┐
│ HTTP Timeout: 30 seconds                          │
│ ┌───────────────────────────────────────────────┐ │
│ │ Ask Timeout: 25 seconds                       │ │
│ │ ┌───────────────────────────────────────────┐ │ │
│ │ │ Actor Processing                          │ │ │
│ │ │ (Must complete in 25s)                    │ │ │
│ │ └───────────────────────────────────────────┘ │ │
│ │                                               │ │
│ │ If actor doesn't respond in 25s:             │ │
│ │ → ServiceTimeoutException                    │ │
│ │ → RestRoutes maps to 504 Gateway Timeout     │ │
│ │ → Client gets response in ~25s               │ │
│ └───────────────────────────────────────────────┘ │
│                                                   │
│ If HTTP timeout (30s) triggers:                  │
│ → Actor ask already timed out (at 25s)           │
│ → Client gets 504 with "actor timeout" message   │
└───────────────────────────────────────────────────┘
```

**Benefits:**
1. **Predictable Errors:** Always get "actor timeout" (not generic HTTP timeout)
2. **Fast Failure:** Actor timeout triggers first (25s, not 30s)
3. **Buffer Time:** 5s buffer prevents race conditions

### Timeout Values

| Timeout Type | Value | Purpose | Trigger |
|--------------|-------|---------|---------|
| Ask Timeout | 25s | Actor ask operations | Actor doesn't respond |
| Circuit Breaker Call Timeout | 25s | Circuit breaker protection | Must equal ask timeout |
| HTTP Timeout | 30s | Client request timeout | Must be > ask timeout |
| Graceful Shutdown | 10s | In-flight request completion | System shutdown initiated |

**Validation:** `InterfacesConfig` validates hierarchy at construction:
```scala
require(
  restTimeout > askTimeout,
  s"REST timeout ($restTimeout) must be greater than ask timeout ($askTimeout). " +
  s"This ensures actor ask timeout triggers before HTTP client timeout."
)

require(
  circuitBreakerCallTimeout == askTimeout,
  s"Circuit breaker call timeout ($circuitBreakerCallTimeout) must equal ask timeout ($askTimeout). " +
  s"This ensures consistent timeout behavior across all actor asks."
)
```

**What Happens on Violation:**
```scala
// This will throw IllegalArgumentException at startup:
InterfacesConfig(
  askTimeout = 30.seconds,
  restTimeout = 25.seconds,  // ❌ restTimeout < askTimeout
  ...
)
// Exception: REST timeout (25 seconds) must be greater than ask timeout (30 seconds)
```

## Configuration Reference

### Configuration File Location

**File:** `/test-probe-interfaces/src/main/resources/reference.conf`

**Format:** HOCON (Human-Optimized Config Object Notation)

**Loading Order:**
1. `reference.conf` (defaults, bundled in JAR)
2. `application.conf` (user overrides, classpath)
3. Environment variables (runtime overrides)
4. System properties (JVM arguments)

### Complete Configuration

```hocon
test-probe.interfaces {

  # REST HTTP Interface Configuration
  rest {
    # Enable/disable REST interface
    enabled = true
    enabled = ${?REST_INTERFACE_ENABLED}

    # Host to bind (0.0.0.0 = all interfaces, 127.0.0.1 = localhost only)
    host = "0.0.0.0"
    host = ${?REST_HOST}

    # Port to bind
    port = 8080
    port = ${?REST_PORT}

    # Request timeout (max time for request processing)
    # Must be > ask-timeout to allow actor response before HTTP timeout
    timeout = 30 seconds

    # Graceful shutdown timeout (wait for in-flight requests)
    graceful-shutdown-timeout = 10 seconds

    # Actor ask timeout (must be < request timeout)
    # Should match core module's test-probe.core.actor-system.timeout (25s)
    ask-timeout = 25s

    # Circuit Breaker Configuration
    # Should match core module's test-probe.core.circuit-breaker settings
    circuit-breaker-max-failures = 5
    circuit-breaker-call-timeout = 25s
    circuit-breaker-reset-timeout = 30s

    # HTTP Server Limits
    # Maximum concurrent requests (backpressure beyond this)
    max-concurrent-requests = 100

    # Maximum request body size (10MB default)
    max-request-size = 10485760

    # Maximum URI length (8KB default)
    max-uri-length = 8192
  }
}

# Pekko HTTP Configuration
# Note: This is at root level (not namespaced) as required by Pekko HTTP
pekko.http {
  server {
    # Request timeout (aligns with test-probe.interfaces.rest.timeout)
    request-timeout = ${test-probe.interfaces.rest.timeout}

    # Idle timeout (how long to keep connection open with no activity)
    idle-timeout = 60s

    # Max connections (concurrent TCP connections)
    max-connections = ${test-probe.interfaces.rest.max-concurrent-requests}

    # Parsing limits
    parsing {
      max-content-length = ${test-probe.interfaces.rest.max-request-size}
      max-uri-length = ${test-probe.interfaces.rest.max-uri-length}
      max-header-count = 64
    }
  }
}
```

### Configuration Parsing

**Implementation:** `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/config/InterfacesConfig.scala` (124 lines)

**Pattern:**
```scala
case class InterfacesConfig(
  restEnabled: Boolean,
  restHost: String,
  restPort: Int,
  restTimeout: FiniteDuration,
  gracefulShutdownTimeout: FiniteDuration,
  askTimeout: FiniteDuration,
  circuitBreakerMaxFailures: Int,
  circuitBreakerCallTimeout: FiniteDuration,
  circuitBreakerResetTimeout: FiniteDuration,
  maxConcurrentRequests: Int,
  maxRequestSize: Long,
  maxUriLength: Int
) extends InterfaceConfig {
  // Validation in constructor
  require(restTimeout > askTimeout, ...)
  require(circuitBreakerCallTimeout == askTimeout, ...)
  require(maxConcurrentRequests > 0, ...)
  // ...
}

object InterfacesConfig {
  def fromConfig(config: Config): InterfacesConfig = {
    val interfacesConfig = config.getConfig("test-probe.interfaces")
    InterfacesConfig(
      restEnabled = interfacesConfig.getBoolean("rest.enabled"),
      restHost = interfacesConfig.getString("rest.host"),
      // ... all fields
    )
  }
}
```

**Validation Benefits:**
- Fail fast at startup (not at runtime)
- Clear error messages
- Type-safe durations (no "infinite" durations)
- Consistent validation logic

## Circuit Breaker Configuration

### Purpose

**Circuit Breaker Pattern:** Prevent cascading failures by failing fast when system is unhealthy.

**States:**
1. **Closed** (normal): Requests pass through
2. **Open** (failing): Fail fast, don't call actor
3. **Half-Open** (testing): Allow 1 request to test recovery

### Configuration Values

```hocon
circuit-breaker-max-failures = 5        # Open after 5 consecutive failures
circuit-breaker-call-timeout = 25s      # Must equal ask-timeout
circuit-breaker-reset-timeout = 30s     # Half-open after 30 seconds
```

**Explanation:**

| Config | Value | Meaning |
|--------|-------|---------|
| `max-failures` | 5 | After 5 consecutive failures, circuit opens |
| `call-timeout` | 25s | Timeout for each call (MUST equal ask-timeout) |
| `reset-timeout` | 30s | After 30s, circuit moves to Half-Open |

### State Transitions

```
Closed (normal operation)
   │
   ├─ Success → Stay Closed
   │
   ├─ Failure (count < 5) → Stay Closed (increment failure count)
   │
   └─ Failure (count = 5) → Open
                             │
                             │ (30 seconds pass)
                             ↓
                          Half-Open (allow 1 request)
                             │
                             ├─ Success → Closed (reset failure count)
                             │
                             └─ Failure → Open (restart 30s timer)
```

### Circuit Breaker Behavior

**Closed State:**
```scala
// Normal operation
val result = circuitBreaker.withCircuitBreaker {
  guardian.ask[Response](command)
}
// If success: Continue
// If failure: Increment counter, throw exception
// If failure count = 5: Open circuit
```

**Open State:**
```scala
// Fail fast (don't call actor)
val result = circuitBreaker.withCircuitBreaker {
  // This block NOT executed
  guardian.ask[Response](command)
}
// Immediately throws: ServiceUnavailableException
// RestRoutes returns: 503 Service Unavailable (retryAfter: "30s")
```

**Half-Open State:**
```scala
// After 30s, circuit allows 1 test request
val result = circuitBreaker.withCircuitBreaker {
  guardian.ask[Response](command)
}
// If success: Circuit closes, normal operation resumes
// If failure: Circuit reopens, wait another 30s
```

### Why call-timeout MUST Equal ask-timeout

**Problem:** If timeouts differ, inconsistent behavior:
```scala
// BAD: Different timeouts
circuit-breaker-call-timeout = 30s
ask-timeout = 25s

// Actor ask times out at 25s
// Circuit breaker still waiting (timeout at 30s)
// Circuit breaker sees success (ask completed, albeit with timeout)
// Failure count NOT incremented → Circuit never opens!
```

**Solution:** Same timeout guarantees consistency:
```scala
// GOOD: Same timeout
circuit-breaker-call-timeout = 25s
ask-timeout = 25s

// Actor ask times out at 25s
// Circuit breaker times out at 25s
// Circuit breaker sees failure
// Failure count incremented → Circuit opens after 5 failures
```

**Validation:**
```scala
require(
  circuitBreakerCallTimeout == askTimeout,
  s"Circuit breaker call timeout ($circuitBreakerCallTimeout) must equal ask timeout ($askTimeout)"
)
```

### Production Example

**Scenario:** Database connection pool exhausted

```
1. Request 1: Actor ask → DB connection pool exhausted → Timeout (25s)
   Circuit: Closed (failure count = 1)

2. Request 2: Actor ask → DB connection pool exhausted → Timeout (25s)
   Circuit: Closed (failure count = 2)

3. Request 3-5: Same (failures 3, 4, 5)
   Circuit: Opens after 5th failure

4. Request 6: Circuit open → Fail fast → ServiceUnavailableException
   Response: 503 Service Unavailable (retryAfter: "30s")
   Time: <1ms (no actor ask, immediate failure)

5. (30 seconds pass)
   Circuit: Half-Open (allow 1 test request)

6. Request 7: DB connection pool recovered → Success
   Circuit: Closes

7. Request 8+: Normal operation resumed
```

**Benefits:**
- Requests 6+ fail fast (<1ms, not 25s)
- Prevents overwhelming actor system with doomed requests
- Auto-recovery after 30s (no manual intervention)

## Graceful Shutdown

### Purpose

**Goal:** Allow in-flight requests to complete before shutting down HTTP server.

**Configuration:**
```hocon
graceful-shutdown-timeout = 10 seconds
```

### Shutdown Sequence

```
1. Shutdown signal received (SIGTERM, Ctrl+C, etc.)
   ↓
2. HTTP server stops accepting new requests
   ↓
3. Wait up to 10 seconds for in-flight requests to complete
   ↓
4. (In-flight requests complete within 10s)
   ↓
5. HTTP server terminates cleanly
   ↓
6. Actor system shuts down
   ↓
7. Application exits

Alternative:
3. Wait up to 10 seconds for in-flight requests to complete
   ↓
4. (10 seconds pass, some requests still in-flight)
   ↓
5. Force shutdown (terminate remaining requests)
   ↓
6. HTTP server terminates
   ↓
7. Actor system shuts down
   ↓
8. Application exits
```

### Choosing Graceful Shutdown Timeout

**Too Short (e.g., 1s):**
- Most requests interrupted mid-processing
- Clients see connection errors
- Wasted work (partial processing)

**Too Long (e.g., 60s):**
- Deployment/restart takes too long
- Kubernetes may force-kill (SIGKILL) before graceful shutdown completes

**Recommended: 10s**
- Enough time for most requests (ask timeout = 25s, but most complete <10s)
- Fast enough for Kubernetes rolling updates
- Balance between clean shutdown and deployment speed

### Kubernetes Integration

**Kubernetes Termination Lifecycle:**
```yaml
# deployment.yaml
spec:
  template:
    spec:
      containers:
      - name: test-probe
        # ...
      terminationGracePeriodSeconds: 30  # Must be > graceful-shutdown-timeout
```

**Shutdown Sequence:**
```
1. Kubernetes sends SIGTERM to pod
   ↓
2. Test Probe starts graceful shutdown (10s timeout)
   ↓
3. In-flight requests complete (within 10s)
   ↓
4. HTTP server terminates
   ↓
5. Actor system shuts down
   ↓
6. Application exits (before 30s terminationGracePeriodSeconds)
   ↓
7. Kubernetes removes pod

Alternative (timeout exceeded):
3. In-flight requests still running after 10s
   ↓
4. Test Probe force-terminates HTTP server
   ↓
5. Actor system shuts down
   ↓
6. Application exits (still before 30s)
   ↓
7. Kubernetes removes pod

Worst case (app hangs):
3-6. Application hangs, doesn't exit
   ↓
7. (30s terminationGracePeriodSeconds passes)
   ↓
8. Kubernetes sends SIGKILL (force kill)
```

**Best Practice:** Set `terminationGracePeriodSeconds` to 2-3x `graceful-shutdown-timeout`:
```
graceful-shutdown-timeout = 10s
terminationGracePeriodSeconds = 30s  # 3x safety margin
```

## HTTP Server Limits

### Purpose

**Goal:** Prevent server overload by limiting concurrent connections and request sizes.

### Configuration Values

```hocon
# Maximum concurrent requests (backpressure beyond this)
max-concurrent-requests = 100

# Maximum request body size (10MB default)
max-request-size = 10485760

# Maximum URI length (8KB default)
max-uri-length = 8192
```

### Max Concurrent Requests

**Meaning:** Maximum number of requests being processed simultaneously.

**Behavior:**
- Request 1-100: Processed immediately
- Request 101+: Queued (backpressure)
- When request completes: Next queued request starts

**Choosing Value:**
- **Too Low (e.g., 10):** Unnecessary queueing, underutilized resources
- **Too High (e.g., 10,000):** Actor system overload, high memory usage
- **Recommended: 100-200:** Balance between throughput and stability

**Load Testing:**
```bash
# Simulate 200 concurrent requests
ab -n 1000 -c 200 http://localhost:8080/api/v1/health

# If response times increase significantly beyond 100 concurrent:
# → Reduce max-concurrent-requests
# If response times stay flat up to 200 concurrent:
# → Can increase max-concurrent-requests
```

### Max Request Size

**Meaning:** Maximum HTTP request body size (in bytes).

**Default:** 10MB (10485760 bytes)

**Rationale:**
- Test feature files: ~1KB - 100KB
- JSON requests: <10KB
- Large feature bundles: 1MB - 10MB

**Override Example:**
```hocon
# Allow 50MB for large feature file uploads
max-request-size = 52428800  # 50MB
```

**Security Note:** Prevent DoS attacks via large request bodies.

### Max URI Length

**Meaning:** Maximum URL length (path + query string).

**Default:** 8KB (8192 bytes)

**Typical URIs:**
```
# Short: 50 bytes
GET /api/v1/health

# Medium: 100 bytes
GET /api/v1/test/550e8400-e29b-41d4-a716-446655440000/status

# Long: 120 bytes
GET /api/v1/queue/status?testId=550e8400-e29b-41d4-a716-446655440000

# Very long: 200+ bytes (edge case)
GET /api/v1/test/550e8400-e29b-41d4-a716-446655440000/status?filter=...&sort=...
```

**8KB is sufficient for all practical URIs.**

**Override Example:**
```hocon
# Reduce for security (prevent large URI DoS)
max-uri-length = 2048  # 2KB
```

## Environment Variable Overrides

### Supported Variables

**Pattern:** Configuration keys can be overridden via environment variables.

**Syntax:** `${?ENV_VAR}` in HOCON means "override from ENV_VAR if set".

**Supported Overrides:**
```bash
# Enable/disable REST interface
export REST_INTERFACE_ENABLED=false

# Bind host
export REST_HOST=127.0.0.1

# Bind port
export REST_PORT=9090
```

**Example:**
```bash
# Start with custom port
export REST_PORT=9090
java -jar test-probe-boot.jar
# HTTP server binds to 0.0.0.0:9090
```

### Docker/Kubernetes Examples

**Docker:**
```bash
docker run \
  -e REST_HOST=0.0.0.0 \
  -e REST_PORT=8080 \
  test-probe:latest
```

**Kubernetes:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-probe
spec:
  template:
    spec:
      containers:
      - name: test-probe
        image: test-probe:latest
        env:
        - name: REST_HOST
          value: "0.0.0.0"
        - name: REST_PORT
          value: "8080"
        - name: REST_INTERFACE_ENABLED
          value: "true"
```

### System Property Overrides

**Alternative:** Override via JVM system properties:
```bash
java \
  -Dtest-probe.interfaces.rest.port=9090 \
  -Dtest-probe.interfaces.rest.host=127.0.0.1 \
  -jar test-probe-boot.jar
```

**Precedence:** System properties > Environment variables > application.conf > reference.conf

## Production Tuning Guidelines

### Timeout Tuning

**Default Values (suitable for most cases):**
```hocon
ask-timeout = 25s
rest-timeout = 30s
circuit-breaker-call-timeout = 25s
circuit-breaker-reset-timeout = 30s
```

**When to Increase:**
- Long-running tests (>25s to download large S3 artifacts)
- High network latency (>5s to reach S3/Vault)
- Heavy load (actor mailbox backlog)

**When to Decrease:**
- Fast tests (complete in <10s)
- Low latency environment (local network)
- Need faster feedback on failures

**Example (long-running tests):**
```hocon
ask-timeout = 60s
rest-timeout = 65s
circuit-breaker-call-timeout = 60s
```

**⚠️ IMPORTANT:** Always maintain hierarchy:
- `rest-timeout > ask-timeout` (at least 5s buffer)
- `circuit-breaker-call-timeout == ask-timeout`

### Circuit Breaker Tuning

**Default:**
```hocon
circuit-breaker-max-failures = 5
circuit-breaker-reset-timeout = 30s
```

**Aggressive (fail fast, prefer availability):**
```hocon
circuit-breaker-max-failures = 3     # Open after 3 failures
circuit-breaker-reset-timeout = 15s  # Retry sooner
```

**Conservative (tolerate failures, prefer completion):**
```hocon
circuit-breaker-max-failures = 10    # Tolerate more failures
circuit-breaker-reset-timeout = 60s  # Wait longer before retry
```

**Metrics to Monitor:**
- Circuit breaker open frequency
- Circuit breaker open duration
- Success rate after circuit closes

### Concurrency Tuning

**Default:**
```hocon
max-concurrent-requests = 100
```

**Low-resource environment (dev/test):**
```hocon
max-concurrent-requests = 20
```

**High-resource environment (production):**
```hocon
max-concurrent-requests = 500
```

**Tuning Process:**
1. Start with default (100)
2. Load test with realistic traffic
3. Monitor:
   - CPU usage
   - Memory usage
   - Response time (p50, p95, p99)
   - Queue depth
4. Increase if:
   - CPU < 70%
   - Memory < 80%
   - Response times flat
5. Decrease if:
   - CPU > 90%
   - Memory > 90%
   - Response times increasing

## Troubleshooting

### Timeout Hierarchy Violations

**Symptom:** `IllegalArgumentException` at startup
```
java.lang.IllegalArgumentException: REST timeout (25 seconds) must be greater than ask timeout (30 seconds)
```

**Cause:** Invalid timeout configuration.

**Solution:** Ensure `restTimeout > askTimeout`:
```hocon
ask-timeout = 25s
rest-timeout = 30s  # Must be > 25s
```

### Circuit Breaker Call Timeout Mismatch

**Symptom:** `IllegalArgumentException` at startup
```
java.lang.IllegalArgumentException: Circuit breaker call timeout (30 seconds) must equal ask timeout (25 seconds)
```

**Cause:** Inconsistent timeout configuration.

**Solution:** Ensure `circuitBreakerCallTimeout == askTimeout`:
```hocon
ask-timeout = 25s
circuit-breaker-call-timeout = 25s  # Must equal 25s
```

### Frequent Circuit Breaker Opens

**Symptom:** High rate of 503 Service Unavailable responses.

**Cause:** System unhealthy (actor failures, timeouts).

**Debug:**
1. Check actor system health: `GET /api/v1/health`
2. Review logs for actor exceptions
3. Monitor ask timeout frequency
4. Check external dependencies (S3, Vault, Kafka)

**Solutions:**
- Increase `ask-timeout` if operations legitimately take >25s
- Fix actor bugs causing failures
- Increase `circuit-breaker-max-failures` to tolerate transient failures
- Check external service health

### Graceful Shutdown Timeout Exceeded

**Symptom:** In-flight requests interrupted during shutdown.

**Cause:** Requests taking longer than `graceful-shutdown-timeout` (10s).

**Solutions:**
- Increase `graceful-shutdown-timeout` (e.g., 20s)
- Ensure `terminationGracePeriodSeconds` > `graceful-shutdown-timeout`
- Optimize slow operations (reduce `ask-timeout` if possible)

### Too Many Concurrent Requests

**Symptom:** High memory usage, slow response times.

**Cause:** `max-concurrent-requests` too high for available resources.

**Debug:**
1. Monitor JVM heap usage
2. Monitor actor mailbox sizes
3. Check response time percentiles (p95, p99)

**Solutions:**
- Decrease `max-concurrent-requests` (e.g., 50)
- Increase JVM heap size (`-Xmx`)
- Scale horizontally (more instances)

## Related Documentation

**Architecture:**
- [REST API Architecture](03.1-rest-api-architecture.md) - Overall design
- [REST Error Handling](03.1-rest-error-handling.md) - Exception and rejection handling
- [REST API Endpoints](03.1-rest-api-endpoints.md) - Endpoint reference

**ADRs:**
- [ADR-REST-002: Validation Pattern](adr/ADR-REST-002-VALIDATION-PATTERN.md) - Configuration validation

**Diagrams:**
- [Circuit Breaker Integration](diagrams/rest-circuit-breaker.mermaid)

**Implementation Files:**
- `/test-probe-interfaces/src/main/scala/io/distia/probe/interfaces/config/InterfacesConfig.scala` (124 lines)
- `/test-probe-interfaces/src/main/resources/reference.conf` (84 lines)

**Tests:**
- `/test-probe-interfaces/src/test/scala/io/distia/probe/interfaces/config/InterfacesConfigSpec.scala` (timeout validation tests)

---

**Last Updated:** 2025-10-19
**Status:** Production-Ready
**Module:** test-probe-interfaces
**Configuration:** Type-safe with compile-time validation
