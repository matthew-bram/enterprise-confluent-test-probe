# 04.2.1 Vault Service Integration Architecture

**Last Updated:** 2025-10-23
**Status:** Active - AzureVaultService Implemented
**Component:** test-probe-services/vault, AzureVaultService
**Related Documents:**
- [ADR-VAULT-001: Rosetta Mapping Pattern](../../adr/ADR-VAULT-001-rosetta-mapping-pattern.md)
- [Rosetta Vault Mapping API](../../../../api/rosetta-vault-mapping-api.md)
- [Bidirectional Flow Diagram](../../diagrams/sequences/rosetta-bidirectional-flow.mermaid)

---

## Table of Contents

1. [Overview](#overview)
2. [Bidirectional Architecture](#bidirectional-architecture)
3. [RequestBodyBuilder Pattern](#requestbodybuilder-pattern)
4. [VaultService Integration Flow](#vaultservice-integration-flow)
5. [Security Validation](#security-validation)
6. [Implementation Reference](#implementation-reference)
7. [Usage Examples](#usage-examples)

---

## Overview

The Vault Service Integration provides a **bidirectional**, configuration-driven approach to vault API communication:

1. **Request Building**: Dynamic vault API request body generation using template variable substitution
2. **Response Mapping**: Flexible JSON response parsing using JSONPath and transformations

This architecture enables the test-probe framework to integrate with heterogeneous enterprise vault implementations (Azure Key Vault, AWS Secrets Manager, HashiCorp Vault) without code changes.

### Key Components

```
BlockStorageService → TopicDirective (with metadata) → AzureVaultService
                                                         ↓
                                                    RequestBodyBuilder
                                                         ↓
                                                      Vault API
                                                         ↓
                                                   Response JSON
                                                         ↓
                                              VaultCredentialsMapper
                                                         ↓
                                                  JaasConfigBuilder
                                                         ↓
                                              KafkaSecurityDirective
```

### Design Goals

1. **Flexibility**: Support any vault API structure via configuration
2. **Security**: Enforce namespace boundaries for config access
3. **Testability**: All components independently testable
4. **Error Clarity**: Accumulate and report all validation errors
5. **Type Safety**: Compile-time guarantees where possible

---

## Bidirectional Architecture

### Phase 1: Request Building (TopicDirective → Vault API)

**Purpose**: Generate dynamic vault API request bodies based on test context

**Flow**:
```
TopicDirective (topic, role, clientPrincipal, metadata Map)
    + RosettaConfig (request-template)
    + application.conf (request-params.*)
    ↓
RequestBodyBuilder.build()
    ↓
JSON request body string
    ↓
HTTP POST to vault API
```

**Variable Sources**:
1. **Config Path**: `{{$^request-params.vault-requests.oauth-id}}`
   - Source: `application.conf`
   - Validation: MUST start with `request-params.` namespace
   - Use Case: Static per-environment configuration (OAuth app IDs, function URLs)

2. **Metadata Key**: `{{'blood-type'}}`
   - Source: `TopicDirective.metadata` Map
   - Loaded From: Block storage YAML (test-metadata.yaml)
   - Use Case: Test-specific, domain-specific data

3. **Directive Field**: `{{topic}}`
   - Source: `TopicDirective` built-in fields
   - Valid Fields: `topic`, `role`, `clientPrincipal`
   - Use Case: Framework-level test context

### Phase 2: Response Mapping (Vault API → SecurityDirective)

**Purpose**: Parse vault responses into framework security model

**Flow**:
```
Vault JSON Response
    ↓
VaultCredentialsMapper.mapToVaultCredentials()
    + RosettaConfig (mappings)
    ↓
VaultCredentials (topic, role, clientId, clientSecret)
    ↓
JaasConfigBuilder.build()
    + OAuth config from application.conf
    ↓
KafkaSecurityDirective (topic, role, clientPrincipal, jaasConfig)
```

**Response Mapping Features**:
- JSONPath expressions for deep nesting (6+ levels supported)
- Transformation pipeline (base64Decode, toUpper, concat, etc.)
- Error accumulation (reports all missing fields, not just first)

---

## RequestBodyBuilder Pattern

### Implementation

**Location**: `test-probe-services/src/main/scala/io/distia/probe/services/vault/RequestBodyBuilder.scala`

**Key Methods**:

```scala
object RequestBodyBuilder {
  // Primary API - builds complete request body
  def build(
    topicDirective: TopicDirective,
    rosettaConfig: RosettaConfig,
    appConfig: Config
  ): Either[VaultMappingException, String]

  // Recursive JSON traversal with variable substitution
  private def substituteVariables(
    json: Json,
    topicDirective: TopicDirective,
    appConfig: Config
  ): Either[VaultMappingException, Json]

  // Security validation
  private def validateConfigPath(
    configPath: String
  ): Either[VaultMappingException, Unit]
}
```

### Template Variable Patterns

**Pattern Matching via Regex**:

```scala
private val ConfigPathPattern: Regex = """\{\{\$\^([^}]+)\}\}""".r
private val MetadataKeyPattern: Regex = """\{\{'([^']+)'\}\}""".r
private val DirectiveFieldPattern: Regex = """\{\{([a-zA-Z]+)\}\}""".r
```

**Resolution Logic**:

```scala
def substituteStringValue(
  value: String,
  topicDirective: TopicDirective,
  appConfig: Config
): Either[VaultMappingException, String] = value match {
  case ConfigPathPattern(configPath) =>
    resolveConfigPath(configPath, appConfig, topicDirective.topic)

  case MetadataKeyPattern(metadataKey) =>
    resolveMetadataKey(metadataKey, topicDirective)

  case DirectiveFieldPattern(fieldName) =>
    resolveDirectiveField(fieldName, topicDirective)

  case _ =>
    Right(value) // Literal string, no substitution
}
```

### Error Accumulation

RequestBodyBuilder accumulates ALL errors before failing:

```scala
// Multiple errors in template
val errors = List(
  "Invalid config path: 'database.password'. Must start with 'request-params.' namespace",
  "Metadata key 'missing-key' not found. Available: [blood-type, test-run-id]",
  "Invalid directive field: 'invalidField'. Valid: [topic, role, clientPrincipal]"
)

Left(VaultMappingException(
  s"""Request body building failed for topic '${topicDirective.topic}':
     |${errors.map(e => s"  - $e").mkString("\n")}""".stripMargin
))
```

This approach provides developers with complete diagnostics in a single error message.

---

## VaultService Integration Flow

### AzureVaultService.invokeVault()

**Location**: `test-probe-services/src/main/scala/io/distia/probe/services/builder/modules/AzureVaultService.scala` (lines 118-162)

**Complete Flow**:

```scala
def invokeVault(topicDirective: TopicDirective)(implicit ec: ExecutionContext): Future[String] = {
  // Phase 1: Build request body
  RequestBodyBuilder.build(topicDirective, rosettaConfig.get, appConfig.get) match {
    case Left(error) =>
      Future.failed(error)

    case Right(payload) =>
      // Phase 2: HTTP POST to vault
      httpClient.get.post(
        uri = functionUrl.get,
        jsonPayload = payload,
        headers = Map(
          "Content-Type" -> "application/json",
          "x-functions-key" -> functionKey.get
        )
      ).flatMap {
        case (200 | 201, Some(body)) =>
          Future.successful(body)

        case (401 | 403, _) =>
          Future.failed(new VaultAuthException(
            s"Azure vault authentication failed for topic ${topicDirective.topic}"
          ))

        case (404, _) =>
          Future.failed(new VaultNotFoundException(
            s"Azure function not found at ${functionUrl.get}"
          ))

        case (429, body) =>
          Future.failed(new VaultRateLimitException(
            s"Azure vault rate limit exceeded: ${body.getOrElse("no details")}"
          ))

        case (503, body) =>
          Future.failed(new VaultServiceUnavailableException(
            s"Azure vault unavailable: ${body.getOrElse("no details")}"
          ))

        case (statusCode, body) =>
          Future.failed(new VaultException(
            s"Azure vault returned HTTP $statusCode: ${body.getOrElse("no response body")}"
          ))
      }
  }
}
```

### Retry Logic with Exponential Backoff

```scala
def fetchWithRetry(
  topicDirective: TopicDirective,
  retriesLeft: Int
)(implicit ec: ExecutionContext): Future[KafkaSecurityDirective] = {
  invokeVault(topicDirective).flatMap { responseBody =>
    // Parse response using VaultCredentialsMapper
    parseAndMapCredentials(responseBody, topicDirective)
  }.recoverWith {
    case e: VaultRateLimitException if retriesLeft > 0 =>
      val delay = calculateBackoff(retriesLeft)
      after(delay, system.scheduler)(fetchWithRetry(topicDirective, retriesLeft - 1))

    case e: VaultServiceUnavailableException if retriesLeft > 0 =>
      val delay = calculateBackoff(retriesLeft)
      after(delay, system.scheduler)(fetchWithRetry(topicDirective, retriesLeft - 1))

    case e: Throwable =>
      Future.failed(e)
  }
}
```

**Backoff Strategy**:
- Initial delay: 1 second
- Multiplier: 2x per retry
- Max retries: 3 (default, configurable)
- Only retries: 429 (rate limit), 503 (service unavailable)

---

## Security Validation

### Config Path Namespace Enforcement

**Problem**: Template variables should not access sensitive configuration (database passwords, API keys, internal secrets).

**Solution**: Enforce `request-params.*` namespace for all config paths.

**Implementation**:

```scala
private val RequiredConfigPrefix: String = "request-params."
private val SafeConfigPathRegex: Regex = """^request-params\.[a-zA-Z0-9._-]+$""".r

def validateConfigPath(configPath: String): Either[VaultMappingException, Unit] = {
  if !configPath.startsWith(RequiredConfigPrefix) then
    Left(new VaultMappingException(
      s"""Invalid config path: '$configPath'.
         | Config paths must start with 'request-params.' namespace.""".stripMargin
    ))
  else if configPath == RequiredConfigPrefix then
    Left(new VaultMappingException(
      s"""Invalid config path: '$configPath'.
         | Config paths must have at least one sub-path after 'request-params.'
         | Format: request-params.[subpath]""".stripMargin
    ))
  else if !SafeConfigPathRegex.matches(configPath) then
    Left(new VaultMappingException(
      s"""Invalid config path: '$configPath'.
         | Config paths must match pattern: request-params.[a-zA-Z0-9._-]+""".stripMargin
    ))
  else
    Right(())
}
```

**Validation Rules**:
1. MUST start with `request-params.`
2. MUST have at least one sub-path (e.g., `request-params.oauth-id`)
3. MUST only contain alphanumeric, underscore, dash, and dot characters

**Examples**:
```
✅ request-params.vault-requests.oauth-id
✅ request-params.azure.function-url
✅ request-params.teams.mf-team.client-app-id
❌ database.password (doesn't start with request-params.)
❌ vault.admin.secret (doesn't start with request-params.)
❌ request-params. (no sub-path)
❌ request-params.invalid@char (invalid character)
```

### Benefits of Namespace Enforcement

1. **Security**: Prevents accidental exposure of sensitive config
2. **Auditability**: All vault request parameters are under one namespace
3. **Clarity**: Explicit separation between vault parameters and internal config
4. **Fail-Fast**: Validation errors caught at template build time, before vault API call

---

## Implementation Reference

### File Locations

**Services Module**:
```
test-probe-services/src/main/scala/io/distia/probe/services/
├── vault/
│   ├── RequestBodyBuilder.scala      # 150 lines - request template building
│   ├── VaultCredentialsMapper.scala  # Response mapping
│   └── JaasConfigBuilder.scala       # JAAS config construction
└── builder/modules/
    ├── AzureVaultService.scala       # Azure Function App integration
    ├── AwsVaultService.scala         # AWS Secrets Manager integration
    └── LocalVaultService.scala       # Local file-based vault (testing)
```

**Common Module**:
```
test-probe-common/src/main/scala/io/distia/probe/common/
├── rosetta/
│   ├── RosettaConfig.scala           # YAML/JSON config parsing
│   ├── RosettaMapper.scala           # JSONPath resolver
│   └── RosettaTransformations.scala  # Transformation pipeline
└── models/
    ├── TopicDirective.scala          # Test context model
    └── KafkaSecurityDirective.scala  # Security model with JAAS config
```

### Dependencies

**Maven Coordinates**:
```xml
<!-- Circe for JSON manipulation -->
<dependency>
  <groupId>io.circe</groupId>
  <artifactId>circe-core_3</artifactId>
  <version>0.14.10</version>
</dependency>

<!-- Circe YAML for Rosetta config parsing -->
<dependency>
  <groupId>io.circe</groupId>
  <artifactId>circe-yaml_3</artifactId>
  <version>0.15.3</version>
</dependency>

<!-- Typesafe Config for application.conf -->
<dependency>
  <groupId>com.typesafe</groupId>
  <artifactId>config</artifactId>
  <version>1.4.3</version>
</dependency>
```

---

## Usage Examples

### Example 1: Simple Vault (HIP Team)

**Scenario**: Vault only needs OAuth app ID from config.

**Rosetta Config** (`hip-team-simple-vault.yaml`):
```yaml
request-template:
  oauth-id: "{{$^request-params.vault-requests.hip-team.oauth-id}}"

mappings:
  - targetField: clientId
    sourcePath: $.credentials.clientId
  - targetField: clientSecret
    sourcePath: $.credentials.clientSecret
    transformations:
      - type: base64Decode
```

**Application Config**:
```hocon
request-params {
  vault-requests {
    hip-team {
      oauth-id = "HIP-PROD-CONSUMER-APP-456"
    }
  }
}
```

**Generated Request Body**:
```json
{
  "oauth-id": "HIP-PROD-CONSUMER-APP-456"
}
```

### Example 2: Complex Vault (MF Team)

**Scenario**: Vault needs config values, test metadata, and directive fields.

**Rosetta Config** (`mf-team-complex-vault.yaml`):
```yaml
request-template:
  client-app-id: "{{$^request-params.vault-requests.mf-team.client-app-id}}"
  blood-type: "{{'blood-type'}}"
  topic: "{{topic}}"
  role: "{{role}}"

mappings:
  - targetField: clientId
    sourcePath: $.data.credentials.clientId
  - targetField: clientSecret
    sourcePath: $.data.credentials.clientSecret
    transformations:
      - type: base64Decode
```

**Application Config**:
```hocon
request-params {
  vault-requests {
    mf-team {
      client-app-id = "MF-PROD-CONSUMER-APP-123"
    }
  }
}
```

**Block Storage Metadata** (`test-metadata.yaml`):
```yaml
test-metadata:
  blood-type: "O-negative"
  test-run-id: "run-2025-01-22-12345"
```

**TopicDirective**:
```scala
TopicDirective(
  topic = "orders.events",
  role = "PRODUCER",
  clientPrincipal = "service-account-123",
  metadata = Map("blood-type" -> "O-negative", "test-run-id" -> "run-123")
)
```

**Generated Request Body**:
```json
{
  "client-app-id": "MF-PROD-CONSUMER-APP-123",
  "blood-type": "O-negative",
  "topic": "orders.events",
  "role": "PRODUCER"
}
```

### Example 3: Nested Structure

**Rosetta Config**:
```yaml
request-template:
  auth:
    client-id: "{{$^request-params.azure.client-id}}"
    scope: "{{$^request-params.azure.scope}}"
  context:
    topic: "{{topic}}"
    metadata:
      blood-type: "{{'blood-type'}}"
      run-id: "{{'test-run-id'}}"

mappings:
  # ... response mappings
```

**Generated Request Body**:
```json
{
  "auth": {
    "client-id": "AZURE-APP-123",
    "scope": "kafka.producer"
  },
  "context": {
    "topic": "orders.events",
    "metadata": {
      "blood-type": "O-negative",
      "run-id": "run-2025-01-22-12345"
    }
  }
}
```

---

## Related Documentation

**Architecture Decision Records**:
- [ADR-VAULT-001: Rosetta Mapping Pattern](../../adr/ADR-VAULT-001-rosetta-mapping-pattern.md)

**API Documentation**:
- [Rosetta Vault Mapping API](../../../../api/rosetta-vault-mapping-api.md) - Comprehensive API reference

**Diagrams**:
- [Bidirectional Flow Sequence](../../diagrams/sequences/rosetta-bidirectional-flow.mermaid)
- [Component Diagram](../../diagrams/components/rosetta-vault-mapping-components.mermaid)
- [Response Flow Sequence](../../diagrams/sequences/rosetta-vault-mapping-sequence.mermaid)

**Examples**:
- [Rosetta Examples Directory](../../../../examples/rosetta/) - YAML templates, application.conf examples, usage guide

**Implementation Files**:
- RequestBodyBuilder: `test-probe-services/src/main/scala/io/distia/probe/services/vault/RequestBodyBuilder.scala` (lines 1-150)
- AzureVaultService: `test-probe-services/src/main/scala/io/distia/probe/services/builder/modules/AzureVaultService.scala` (lines 118-162)

---

## Document History

- 2025-10-23: Initial blueprint created documenting RequestBodyBuilder integration and bidirectional vault architecture
