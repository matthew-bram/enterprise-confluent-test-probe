# 05.3 Child Actors Integration

**Last Updated:** 2025-10-20
**Status:** Complete - All 5 child actors implemented, BlockStorageActor service integration complete
**Component:** TestExecutionActor Child Actors
**Related Documents:**
- [05.1 TestExecutionActor FSM](./05.1-test-execution-actor-fsm.md)
- [05.2 TestExecutionActor Error Handling](./05.2-test-execution-actor-error-handling.md)
- [ADR 004: Factory Injection for Child Actors](../../adr/004-factory-injection-for-child-actors.md)

---

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Child Actor Implementations](#child-actor-implementations)
  - [BlockStorageActor](#blockstorageactor)
  - [VaultActor](#vaultactor)
  - [CucumberExecutionActor](#cucumberexecutionactor)
  - [KafkaProducerActor](#kafkaproductoractor)
  - [KafkaConsumerActor](#kafkaconsumeractor)
- [Parent Reference Pattern](#parent-reference-pattern)
- [Message Protocol](#message-protocol)
- [Security Compliance](#security-compliance)
- [Testing Strategy](#testing-strategy)
- [Service Integration Status](#service-integration-status)
- [Implementation Statistics](#implementation-statistics)

---

## Overview

TestExecutionActor coordinates 5 child actors that handle specific responsibilities during test execution. All child actors are implemented in the scaffolding phase with complete message passing protocols and exception handling, but service integration is deferred to a future phase.

**Design Goals:**
1. **Separation of Concerns**: Each child actor handles a specific domain (storage, security, execution, messaging)
2. **Parent Reference Pattern**: Akka Typed pattern for child-to-parent communication
3. **Sequential Initialization**: Dependency-aware initialization order (BlockStorage → Vault → Cucumber/Kafka)
4. **Security Compliance**: Proper handling of sensitive credentials with logging redaction
5. **Exception Propagation**: All child exceptions bubble to parent for FSM error handling

**Implementation Phase:**
- **BlockStorageActor**: Service integration complete (jimfs + 3 cloud provider skeletons)
- **VaultActor**: Service integration complete (see vault spike documentation)
- **Other Actors**: Scaffolding complete - message passing, exception handling, parent reference pattern
- **Future**: Kafka/Cucumber service integration

---

## Architecture

### Child Actor Hierarchy

```mermaid
graph TD
    TEA[TestExecutionActor FSM]
    TEA -->|spawns| BSA[BlockStorageActor]
    TEA -->|spawns| VA[VaultActor]
    TEA -->|spawns| CEA[CucumberExecutionActor]
    TEA -->|spawns| KPA[KafkaProducerActor]
    TEA -->|spawns| KCA[KafkaConsumerActor]

    BSA -->|BlockStorageFetched| TEA
    BSA -->|ChildGoodToGo| TEA
    BSA -->|BlockStorageUploadComplete| TEA

    VA -->|SecurityFetched| TEA
    VA -->|ChildGoodToGo| TEA

    CEA -->|ChildGoodToGo| TEA
    CEA -->|TestComplete| TEA

    KPA -->|ChildGoodToGo| TEA
    KCA -->|ChildGoodToGo| TEA

    style TEA fill:#ff9999
    style BSA fill:#99ccff
    style VA fill:#99ccff
    style CEA fill:#99ccff
    style KPA fill:#99ccff
    style KCA fill:#99ccff
```

### Initialization Sequence

```mermaid
sequenceDiagram
    participant Q as QueueActor
    participant TEA as TestExecutionActor
    participant BS as BlockStorageActor
    participant V as VaultActor
    participant C as CucumberActor
    participant KP as KafkaProducer
    participant KC as KafkaConsumer

    Q->>TEA: InitializeRequest(testId)
    activate TEA
    Note over TEA: Setup → Loading

    TEA->>BS: spawn + supervise
    TEA->>V: spawn + supervise
    TEA->>C: spawn + supervise
    TEA->>KP: spawn + supervise
    TEA->>KC: spawn + supervise

    TEA->>BS: Initialize(bucket)
    activate BS
    BS->>TEA: BlockStorageFetched(directive)
    BS->>TEA: ChildGoodToGo(self)
    deactivate BS

    TEA->>V: Initialize(blockStorageDirective)
    activate V
    V->>TEA: SecurityFetched(directives)
    V->>TEA: ChildGoodToGo(self)
    deactivate V

    par Parallel Initialization
        TEA->>C: Initialize(blockStorageDirective, securityDirectives)
        activate C
        C->>TEA: ChildGoodToGo(self)
        deactivate C
    and
        TEA->>KP: Initialize(blockStorageDirective, securityDirectives)
        activate KP
        KP->>TEA: ChildGoodToGo(self)
        deactivate KP
    and
        TEA->>KC: Initialize(blockStorageDirective, securityDirectives)
        activate KC
        KC->>TEA: ChildGoodToGo(self)
        deactivate KC
    end

    Note over TEA: 5 ChildGoodToGo received
    Note over TEA: Loading → Loaded

    TEA->>Q: TestLoaded(testId)
    deactivate TEA
```

### Testing Phase Flow

```mermaid
sequenceDiagram
    participant Q as QueueActor
    participant TEA as TestExecutionActor
    participant C as CucumberActor
    participant BS as BlockStorageActor

    Q->>TEA: StartTesting(testId)
    activate TEA
    Note over TEA: Loaded → Testing

    TEA->>C: StartTest
    activate C
    Note over C: Execute Cucumber scenarios
    C->>TEA: TestComplete(result)
    deactivate C

    TEA->>BS: LoadToBlockStorage(result)
    activate BS
    Note over BS: Upload evidence to S3
    BS->>TEA: BlockStorageUploadComplete(testId)
    deactivate BS

    Note over TEA: Testing → Completed
    TEA->>Q: TestCompleted(testId)
    deactivate TEA
```

### Shutdown Flow

```mermaid
sequenceDiagram
    participant TEA as TestExecutionActor
    participant BS as BlockStorageActor
    participant V as VaultActor
    participant C as CucumberActor
    participant KP as KafkaProducer
    participant KC as KafkaConsumer

    Note over TEA: Completed/Exception → ShuttingDown

    par Fire-and-Forget Shutdown
        TEA->>BS: Stop
        activate BS
        BS-->>TEA: (no response)
        deactivate BS
    and
        TEA->>V: Stop
        activate V
        V-->>TEA: (no response)
        deactivate V
    and
        TEA->>C: Stop
        activate C
        C-->>TEA: (no response)
        deactivate C
    and
        TEA->>KP: Stop
        activate KP
        KP-->>TEA: (no response)
        deactivate KP
    and
        TEA->>KC: Stop
        activate KC
        KC-->>TEA: (no response)
        deactivate KC
    end

    Note over TEA: ShuttingDown → Stopped
    Note over TEA: Behaviors.stopped
```

---

## Child Actor Implementations

### BlockStorageActor

**File:** `test-probe-core/src/main/scala/com/company/probe/core/actors/BlockStorageActor.scala` (340 lines)

**Status:** Service integration COMPLETE (2025-10-20)

**Responsibilities:**
1. **Fetch**: Stream test data from block storage (S3/Azure/GCS/jimfs) to jimfs filesystem
2. **Load**: Upload test evidence from jimfs to block storage after test completion
3. **State Management**: Store BlockStorageDirective in actor state between fetch and load operations

**Service Layer Integration:**
- 4 storage service implementations created in `test-probe-services` module
- LocalBlockStorageService: Full jimfs implementation (240 lines)
- AwsBlockStorageService: S3 skeleton with TODOs (330 lines)
- AzureBlockStorageService: Azure Blob skeleton with TODOs (330 lines)
- GcpBlockStorageService: GCS skeleton with TODOs (340 lines)
- Pattern: Curried functions passed through ServiceFunctionsContext

**Message Protocol:**

```scala
object BlockStorageCommands {
  sealed trait BlockStorageCommand
  case class Initialize(bucket: Option[String]) extends BlockStorageCommand

  // Async result messages (pipeToSelf pattern)
  case class FetchResults(results: Either[Throwable, BlockStorageDirective]) extends BlockStorageCommand
  case class LoadResults(results: Either[Throwable, Unit]) extends BlockStorageCommand

  case class LoadToBlockStorage(testExecutionResult: TestExecutionResult) extends BlockStorageCommand
  case object Stop extends BlockStorageCommand
}
```

**Sent Messages:**
- `BlockStorageFetched(testId, blockStorageDirective)` - After successful fetch
- `ChildGoodToGo(testId, self)` - After successful fetch
- `BlockStorageUploadComplete(testId)` - After successful evidence upload

**State Transitions:**
```
Uninitialized → FetchInProgress → Active → LoadInProgress → Active → Stopped
```

**Testing:**
- Unit Tests: 20 tests (BlockStorageActorSpec.scala) - 16 existing + 4 new handler tests
- BDD Scenarios: 14 scenarios (block-storage-actor.feature)
- Step Definitions: BlockStorageActorSteps.scala

**Key Implementation Details:**

```scala
/**
 * BlockStorageActor with pipeToSelf pattern and service function integration
 */
def apply(
  testId: UUID,
  parentTea: ActorRef[TestExecutionCommand],
  fetchFromBlockStorage: (UUID, String) => Future[BlockStorageDirective],  // Curried function
  loadToBlockStorage: (String, TestExecutionResult) => Future[Unit]  // Curried function
): Behavior[BlockStorageCommand] = {
  Behaviors.setup { context =>
    context.log.info(s"BlockStorageActor started for test $testId")
    activeBehavior(testId, initialized = false, None, parentTea, fetchFromBlockStorage, loadToBlockStorage, context)
  }
}

/**
 * Active behavior with BlockStorageDirective state storage
 */
def activeBehavior(
  testId: UUID,
  initialized: Boolean,
  blockStorageDirective: Option[BlockStorageDirective],  // Stored after fetch, used in load
  parentTea: ActorRef[TestExecutionCommand],
  fetchFromBlockStorage: (UUID, String) => Future[BlockStorageDirective],
  loadToBlockStorage: (String, TestExecutionResult) => Future[Unit],
  context: ActorContext[BlockStorageCommand]
): Behavior[BlockStorageCommand]

/**
 * Fetch flow: Initialize → FetchResults
 */
def handleInitialize(
  testId: UUID,
  bucket: Option[String],  // Option from FSM state
  parentTea: ActorRef[TestExecutionCommand],
  fetchFromBlockStorage: (UUID, String) => Future[BlockStorageDirective],
  loadToBlockStorage: (String, TestExecutionResult) => Future[Unit],
  context: ActorContext[BlockStorageCommand]
): Behavior[BlockStorageCommand] = {
  // Resolve Option[String] to String (service layer uses concrete types)
  val resolvedBucket: String = bucket.getOrElse("default-bucket")

  context.log.info(s"Initializing BlockStorageActor for test $testId with bucket $resolvedBucket")

  import context.executionContext
  val fetchFuture: Future[BlockStorageDirective] = fetchFromBlockStorage(testId, resolvedBucket)

  // pipeToSelf: Map Future result to FetchResults message
  context.pipeToSelf(fetchFuture) {
    case Success(directive) => FetchResults(Right(directive))
    case Failure(ex) => FetchResults(Left(ex))
  }

  activeBehavior(testId, initialized = true, None, parentTea, fetchFromBlockStorage, loadToBlockStorage, context)
}

/**
 * Handle fetch results (EXTRACTED FOR TESTABILITY)
 */
def handleFetchResults(
  testId: UUID,
  results: FetchResults,
  parentTea: ActorRef[TestExecutionCommand],
  fetchFromBlockStorage: (UUID, String) => Future[BlockStorageDirective],
  loadToBlockStorage: (String, TestExecutionResult) => Future[Unit],
  context: ActorContext[BlockStorageCommand]
): Behavior[BlockStorageCommand] = {
  results.results match {
    case Right(directive) =>
      context.log.info(s"BlockStorageDirective fetched for test $testId at ${directive.jimfsLocation}")
      parentTea ! BlockStorageFetched(testId, directive)
      parentTea ! ChildGoodToGo(testId, context.self)

      // CRITICAL: Store directive in state for load phase
      activeBehavior(testId, initialized = true, Some(directive), parentTea, fetchFromBlockStorage, loadToBlockStorage, context)

    case Left(ex) =>
      context.log.error(s"Failed to fetch block storage for test $testId: ${ex.getMessage}", ex)
      throw BlockStorageException(s"Failed to fetch block storage for test $testId: ${ex.getMessage}", cause = Some(ex))
  }
}

/**
 * Load flow: LoadToBlockStorage → LoadResults
 */
def handleLoadToBlockStorage(
  testId: UUID,
  testExecutionResult: TestExecutionResult,
  blockStorageDirective: Option[BlockStorageDirective],  // From stored state
  parentTea: ActorRef[TestExecutionCommand],
  fetchFromBlockStorage: (UUID, String) => Future[BlockStorageDirective],
  loadToBlockStorage: (String, TestExecutionResult) => Future[Unit],
  context: ActorContext[BlockStorageCommand]
): Behavior[BlockStorageCommand] = {
  // Extract jimfsLocation from stored directive
  val jimfsLocation = blockStorageDirective match {
    case Some(directive) => directive.jimfsLocation
    case None =>
      throw new IllegalStateException("BlockStorageDirective not available - fetch must complete before load")
  }

  context.log.info(s"Loading evidence to block storage for test $testId from $jimfsLocation")

  import context.executionContext
  val loadFuture: Future[Unit] = loadToBlockStorage(jimfsLocation, testExecutionResult)

  // pipeToSelf: Map Future result to LoadResults message
  context.pipeToSelf(loadFuture) {
    case Success(_) => LoadResults(Right(()))
    case Failure(ex) => LoadResults(Left(ex))
  }

  Behaviors.same
}

/**
 * Handle load results (EXTRACTED FOR TESTABILITY)
 */
def handleLoadResults(
  testId: UUID,
  results: LoadResults,
  blockStorageDirective: Option[BlockStorageDirective],
  parentTea: ActorRef[TestExecutionCommand],
  fetchFromBlockStorage: (UUID, String) => Future[BlockStorageDirective],
  loadToBlockStorage: (String, TestExecutionResult) => Future[Unit],
  context: ActorContext[BlockStorageCommand]
): Behavior[BlockStorageCommand] = {
  results.results match {
    case Right(_) =>
      context.log.info(s"Evidence uploaded to block storage for test $testId")
      parentTea ! BlockStorageUploadComplete(testId)
      activeBehavior(testId, initialized = true, blockStorageDirective, parentTea, fetchFromBlockStorage, loadToBlockStorage, context)

    case Left(ex) =>
      context.log.error(s"Failed to upload evidence for test $testId: ${ex.getMessage}", ex)
      throw BlockStorageException(s"Failed to upload evidence for test $testId: ${ex.getMessage}", cause = Some(ex))
  }
}
```

**Implementation Pattern:**
- **pipeToSelf**: Async operations mapped to internal messages (FetchResults, LoadResults)
- **Extracted Handlers**: handleFetchResults and handleLoadResults for unit testability
- **State Storage**: BlockStorageDirective stored in actor state after fetch for use in load
- **Option Resolution**: Bucket Option[String] → String resolved at actor boundary
- **Service Functions**: Curried functions passed through ServiceFunctionsContext (no direct service dependency)

**Related Documentation:**
- Service Layer: [04.1 Service Layer Architecture](../../blueprint/04%20Adapters/04.1-service-layer-architecture.md)
- ADRs: ADR-STORAGE-001 through ADR-STORAGE-004
- Implementation Summary: `working/storage/STORAGE-IMPLEMENTATION-SUMMARY.md`

---

### VaultActor

**File:** `test-probe-core/src/main/scala/com/company/probe/core/actors/VaultActor.scala` (162 lines)

**Responsibilities:**
1. Fetch client ID and client secret from Vault based on BlockStorageDirective (stub)

**Message Protocol:**

```scala
object VaultCommands {
  sealed trait VaultCommand
  case class Initialize(blockStorageDirective: BlockStorageDirective) extends VaultCommand
  case object Stop extends VaultCommand
}
```

**Sent Messages:**
- `SecurityFetched(testId, securityDirectives)` - After successful Vault fetch
- `ChildGoodToGo(testId, self)` - After successful initialization

**State Transitions (Implicit):**
```
Created → Initialize → Fetching → Ready → Stop → Stopped
```

**Security Compliance:**
- Security warning banner in source file
- All credentials redacted in logs: "credentials REDACTED"
- Exception messages do not contain clientSecret

**Testing:**
- Unit Tests: 8 tests (VaultActorSpec.scala)
- BDD Scenarios: 10 scenarios (vault-actor.feature)
- Step Definitions: VaultActorSteps.scala

**Key Implementation Details:**
```scala
def handleInitialize(
  testId: UUID,
  blockStorageDirective: BlockStorageDirective,
  initialized: Boolean,
  parentTea: ActorRef[TestExecutionCommand],
  context: ActorContext[VaultCommand]
): Behavior[VaultCommand] = {
  // TODO: Service integration - Future phase
  // Stub: Fetch secrets from Vault based on blockStorageDirective
  // ⚠️  DO NOT LOG the SecurityDirective object

  val securityDirectives: List[SecurityDirective] = List(
    SecurityDirective(
      serviceName = "kafka",
      clientId = "stub-client-id",
      clientSecret = "stub-client-secret"
    )
  )

  context.log.info(s"SecurityDirective fetched for test $testId (credentials REDACTED)")
  parentTea ! SecurityFetched(testId, securityDirectives)
  parentTea ! ChildGoodToGo(testId, context.self)

  activeBehavior(testId, initialized = true, parentTea, context)
}
```

---

### CucumberExecutionActor

**File:** `test-probe-core/src/main/scala/com/company/probe/core/actors/CucumberExecutionActor.scala` (226 lines)

**Responsibilities:**
1. Initialize Cucumber test execution environment (stub)
2. Execute Cucumber scenarios (stub returns TestExecutionResult)

**Message Protocol:**

```scala
object CucumberExecutionCommands {
  sealed trait CucumberExecutionCommand
  case class Initialize(
    blockStorageDirective: BlockStorageDirective,
    securityDirectives: List[SecurityDirective]
  ) extends CucumberExecutionCommand
  case object StartTest extends CucumberExecutionCommand
  case object Stop extends CucumberExecutionCommand
}
```

**Sent Messages:**
- `ChildGoodToGo(testId, self)` - After successful initialization
- `TestComplete(testId, testExecutionResult)` - After test execution completes

**State Transitions (Implicit):**
```
Created → Initialize → Initializing → Ready → StartTest → Executing → Stop → Stopped
```

**Security Compliance:**
- Security warning banner in source file
- All credentials redacted in logs: "credentials REDACTED"
- SecurityDirective NOT logged

**Testing:**
- Unit Tests: 12 tests (CucumberExecutionActorSpec.scala)
- BDD Scenarios: 12 scenarios (cucumber-execution-actor.feature)
- Step Definitions: CucumberExecutionActorSteps.scala

**Key Implementation Details:**
```scala
def handleStartTest(
  testId: UUID,
  initialized: Boolean,
  parentTea: ActorRef[TestExecutionCommand],
  context: ActorContext[CucumberExecutionCommand]
): Behavior[CucumberExecutionCommand] = {
  if (!initialized) {
    context.log.error(s"StartTest received before Initialize for test $testId")
    throw new IllegalStateException("CucumberExecutionActor not initialized")
  }

  // TODO: Service integration - Future phase
  // Stub: Execute Cucumber scenarios

  val stubResult: TestExecutionResult = TestExecutionResult(
    testId = testId,
    passed = true,
    scenariosRun = 5,
    scenariosPassed = 5,
    scenariosFailed = 0,
    stepsRun = 20,
    stepsPassed = 20,
    stepsFailed = 0,
    errorMessage = None
  )

  context.log.info(s"Cucumber test execution complete for test $testId")
  parentTea ! TestComplete(testId, stubResult)

  Behaviors.same
}
```

---

### KafkaProducerActor

**File:** `test-probe-core/src/main/scala/com/company/probe/core/actors/KafkaProducerActor.scala` (189 lines)

**Responsibilities:**
1. Configure Kafka producers with credentials (stub)
2. StartTest is no-op stub (producers used by Cucumber scenarios)

**Message Protocol:**

```scala
object KafkaProducerCommands {
  sealed trait KafkaProducerCommand
  case class Initialize(
    blockStorageDirective: BlockStorageDirective,
    securityDirectives: List[SecurityDirective]
  ) extends KafkaProducerCommand
  case object StartTest extends KafkaProducerCommand
  case object Stop extends KafkaProducerCommand
}
```

**Sent Messages:**
- `ChildGoodToGo(testId, self)` - After successful initialization
- Note: StartTest is no-op, does not send messages

**State Transitions (Implicit):**
```
Created → Initialize → Initializing → Ready → (StartTest - no-op) → Stop → Stopped
```

**Security Compliance:**
- Security warning banner in source file
- All credentials redacted in logs: "credentials REDACTED"
- SecurityDirective NOT logged

**Testing:**
- Unit Tests: 12 tests (KafkaProducerActorSpec.scala)
- BDD Scenarios: 8 scenarios (kafka-producer-actor.feature)
- Step Definitions: KafkaProducerActorSteps.scala

**Key Implementation Details:**
```scala
def handleInitialize(
  testId: UUID,
  blockStorageDirective: BlockStorageDirective,
  securityDirectives: List[SecurityDirective],
  initialized: Boolean,
  parentTea: ActorRef[TestExecutionCommand],
  context: ActorContext[KafkaProducerCommand]
): Behavior[KafkaProducerCommand] = {
  // TODO: Service integration - Future phase
  // Stub: Setup Kafka producer connections
  // ⚠️  DO NOT LOG the SecurityDirective objects

  context.log.info(s"Kafka producer initialized for test $testId (credentials REDACTED)")
  parentTea ! ChildGoodToGo(testId, context.self)

  activeBehavior(testId, initialized = true, parentTea, context)
}

def handleStartTest(
  testId: UUID,
  context: ActorContext[KafkaProducerCommand]
): Behavior[KafkaProducerCommand] = {
  // TODO: Service integration - Future phase
  // Stub: No-op for scaffolding phase
  // Future: Accept produce requests from CucumberExecutionActor

  context.log.debug(s"StartTest received for KafkaProducerActor test $testId (no-op)")
  Behaviors.same
}
```

---

### KafkaConsumerActor

**File:** `test-probe-core/src/main/scala/com/company/probe/core/actors/KafkaConsumerActor.scala` (189 lines)

**Responsibilities:**
1. Configure Kafka consumers with credentials (stub)
2. StartTest is no-op stub (consumers used by Cucumber scenarios)

**Message Protocol:**

```scala
object KafkaConsumerCommands {
  sealed trait KafkaConsumerCommand
  case class Initialize(
    blockStorageDirective: BlockStorageDirective,
    securityDirectives: List[SecurityDirective]
  ) extends KafkaConsumerCommand
  case object StartTest extends KafkaConsumerCommand
  case object Stop extends KafkaConsumerCommand
}
```

**Sent Messages:**
- `ChildGoodToGo(testId, self)` - After successful initialization
- Note: StartTest is no-op, does not send messages

**State Transitions (Implicit):**
```
Created → Initialize → Initializing → Ready → (StartTest - no-op) → Stop → Stopped
```

**Security Compliance:**
- Security warning banner in source file
- All credentials redacted in logs: "credentials REDACTED"
- SecurityDirective NOT logged

**Testing:**
- Unit Tests: 12 tests (KafkaConsumerActorSpec.scala)
- BDD Scenarios: 8 scenarios (kafka-consumer-actor.feature)
- Step Definitions: KafkaConsumerActorSteps.scala

**Key Implementation Details:**
```scala
def handleInitialize(
  testId: UUID,
  blockStorageDirective: BlockStorageDirective,
  securityDirectives: List[SecurityDirective],
  initialized: Boolean,
  parentTea: ActorRef[TestExecutionCommand],
  context: ActorContext[KafkaConsumerCommand]
): Behavior[KafkaConsumerCommand] = {
  // TODO: Service integration - Future phase
  // Stub: Setup Kafka consumer connections
  // ⚠️  DO NOT LOG the SecurityDirective objects

  context.log.info(s"Kafka consumer initialized for test $testId (credentials REDACTED)")
  parentTea ! ChildGoodToGo(testId, context.self)

  activeBehavior(testId, initialized = true, parentTea, context)
}

def handleStartTest(
  testId: UUID,
  context: ActorContext[KafkaConsumerCommand]
): Behavior[KafkaConsumerCommand] = {
  // TODO: Service integration - Future phase
  // Stub: No-op for scaffolding phase
  // Future: Accept consume requests from CucumberExecutionActor

  context.log.debug(s"StartTest received for KafkaConsumerActor test $testId (no-op)")
  Behaviors.same
}
```

---

## Parent Reference Pattern

All child actors implement the **Akka Typed parent reference pattern** to enable child-to-parent communication without relying on `context.parent` (which doesn't exist in Akka Typed).

### Pattern Implementation

**Child Actor Signature:**
```scala
def apply(testId: UUID, parentTea: ActorRef[TestExecutionCommand]): Behavior[Command]
```

**TestExecutionActor Factory Pattern:**
```scala
// Factory injection type alias
type BlockStorageFactory = ActorContext[TestExecutionCommand] => ActorRef[BlockStorageCommand]

// Default factory implementation
def defaultBlockStorageFactory(testId: UUID): BlockStorageFactory = { ctx =>
  ctx.spawn(
    Behaviors.supervise(BlockStorageActor(testId, ctx.self))
      .onFailure[Exception](SupervisorStrategy.restart),
    s"block-storage-$testId"
  )
}

// Spawn child with factory
val blockStorageActor: ActorRef[BlockStorageCommand] =
  blockStorageFactory.getOrElse(defaultBlockStorageFactory(testId))(context)
```

**Benefits:**
1. **Explicit Parent Reference**: No reliance on implicit `context.parent`
2. **Type Safety**: Parent reference is typed as `ActorRef[TestExecutionCommand]`
3. **Testability**: Factories enable injection of test probes
4. **Akka Typed Compliance**: Follows Akka Typed best practices

---

## Message Protocol

### Common Patterns

All child actors follow these message protocol patterns:

1. **Initialize Messages**: Carry data dependencies
   - BlockStorageActor: `Initialize(bucket: Option[String])`
   - VaultActor: `Initialize(blockStorageDirective: BlockStorageDirective)`
   - Others: `Initialize(blockStorageDirective, securityDirectives)`

2. **Acknowledgment Messages**: All children send `ChildGoodToGo`
   ```scala
   parentTea ! ChildGoodToGo(testId, context.self)
   ```

3. **Response Messages**: Domain-specific responses
   - BlockStorageActor: `BlockStorageFetched`, `BlockStorageUploadComplete`
   - VaultActor: `SecurityFetched`
   - CucumberExecutionActor: `TestComplete`

4. **Shutdown Messages**: All children handle `Stop`
   ```scala
   case Stop =>
     context.log.info(s"Stopping XyzActor for test $testId")
     Behaviors.stopped
   ```

### Dependency Flow

```mermaid
graph LR
    TEA[TestExecutionActor]
    BS[BlockStorageActor]
    V[VaultActor]
    C[CucumberExecutionActor]
    KP[KafkaProducerActor]
    KC[KafkaConsumerActor]

    TEA -->|bucket| BS
    BS -->|BlockStorageDirective| V
    V -->|SecurityDirective| C
    V -->|SecurityDirective| KP
    V -->|SecurityDirective| KC
    BS -->|BlockStorageDirective| C
    BS -->|BlockStorageDirective| KP
    BS -->|BlockStorageDirective| KC

    style TEA fill:#ff9999
    style BS fill:#99ccff
    style V fill:#ffcc99
    style C fill:#99ff99
    style KP fill:#99ff99
    style KC fill:#99ff99
```

**Initialization Order:**
1. BlockStorageActor initializes first (provides BlockStorageDirective)
2. VaultActor initializes second (provides SecurityDirective)
3. Cucumber/Producer/Consumer initialize in parallel (receive both directives)

---

## Security Compliance

### Actors Handling Sensitive Data

4 actors handle `SecurityDirective` containing sensitive credentials:
- VaultActor (fetches credentials)
- CucumberExecutionActor (receives credentials)
- KafkaProducerActor (receives credentials)
- KafkaConsumerActor (receives credentials)

### Security Requirements

1. **Warning Banner**: All actors handling `SecurityDirective` have security warning banner in source file

```scala
/*
 * ╔══════════════════════════════════════════════════════════════════════╗
 * ║ ⚠️  SECURITY WARNING - SENSITIVE DATA HANDLING                       ║
 * ╠══════════════════════════════════════════════════════════════════════╣
 * ║ This actor handles SecurityDirective containing:                     ║
 * ║ - OAuth client IDs and secrets                                       ║
 * ║ - Vault credentials                                                  ║
 * ║ - Kafka authentication tokens                                        ║
 * ║                                                                      ║
 * ║ ⚠️  DO NOT LOG SecurityDirective OR ANY DERIVED CREDENTIALS          ║
 * ║                                                                      ║
 * ║ All logging must:                                                    ║
 * ║ 1. Exclude SecurityDirective objects from log statements            ║
 * ║ 2. Redact credentials in error messages                             ║
 * ║ 3. Use testId for correlation, never credentials                    ║
 * ║                                                                      ║
 * ║ Future: Security agent will enforce compliance                      ║
 * ╚══════════════════════════════════════════════════════════════════════╝
 */
```

2. **Log Redaction**: All logging statements redact credentials

```scala
context.log.info(s"SecurityDirective fetched for test $testId (credentials REDACTED)")
context.log.info(s"Kafka producer initialized for test $testId (credentials REDACTED)")
```

3. **Exception Safety**: Exception messages do not contain sensitive data

```scala
// WRONG: Never log credentials
context.log.error(s"Failed to fetch credentials: $securityDirective")

// CORRECT: Log testId only
context.log.error(s"Failed to fetch credentials for test $testId")
```

---

## Testing Strategy

### Three-Tier Testing Approach

All child actors are tested using the 70/20/10 testing pyramid:

#### Unit Tests (70%)

**Scope**: Direct method testing using `ActorTestKit`

**Pattern:**
```scala
class BlockStorageActorSpec extends AnyWordSpec with Matchers with BeforeAndAfterAll {
  implicit val testKit: ActorTestKit = ActorTestKit()

  "BlockStorageActor.handleInitialize" should {
    "send BlockStorageFetched and ChildGoodToGo" in {
      val testId: UUID = TestIds.test1
      val parentProbe: TestProbe[TestExecutionCommand] = testKit.createTestProbe()
      val actor: ActorRef[BlockStorageCommand] = testKit.spawn(
        BlockStorageActor(testId, parentProbe.ref)
      )

      actor ! Initialize(Some("test-bucket"))

      parentProbe.expectMessageType[BlockStorageFetched](3.seconds)
      parentProbe.expectMessageType[ChildGoodToGo](3.seconds)
    }
  }
}
```

**Coverage:** 16 tests per actor (BlockStorageActor), 8-12 tests for others

#### BDD Component Tests (20%)

**Scope**: Gherkin scenarios testing actor lifecycle and message protocols

**Pattern:**
```gherkin
@ComponentTest
Feature: Block Storage Actor - S3 Evidence Management

  Scenario: Initialize with bucket sends BlockStorageFetched and ChildGoodToGo
    Given a BlockStorageActor is created for test "test-001"
    When the actor receives Initialize with bucket "evidence-bucket"
    Then the actor should send BlockStorageFetched to the parent
    And the actor should send ChildGoodToGo to the parent
    And the BlockStorageDirective should contain jimfs location "/jimfs/test-test-001"
```

**Coverage:** 8-14 scenarios per actor

#### Integration Tests (10%)

**Scope**: TestExecutionActor FSM integration with all 5 children

**Coverage:** TestExecutionActor BDD scenarios include child actor coordination

### Test Statistics

| Actor | Unit Tests | BDD Scenarios | Total |
|-------|-----------|---------------|-------|
| BlockStorageActor | 16 | 14 | 30 |
| VaultActor | 8 | 10 | 18 |
| CucumberExecutionActor | 12 | 12 | 24 |
| KafkaProducerActor | 12 | 8 | 20 |
| KafkaConsumerActor | 12 | 8 | 20 |
| **TOTAL** | **60** | **52** | **112** |

**Combined with existing tests:** 179/179 tests passing (all actors)

---

## Service Integration Status

### Current Phase: Scaffolding Complete

All service calls are marked with TODO comments for future implementation:

```scala
// TODO: Service integration - Future phase
// This stub will be replaced with actual S3/Vault/Kafka/Cucumber service call
```

### Future Service Integration

#### BlockStorageActor
- **Initialize**: Stream test data from S3 bucket to jimfs local file system
- **LoadToBlockStorage**: Upload test evidence from jimfs to S3 bucket
- **Technologies**: AWS SDK v2, jimfs (in-memory file system)

#### VaultActor
- **Initialize**: Fetch client ID and client secret from HashiCorp Vault
- **Technologies**: Vault HTTP API, Akka HTTP client

#### CucumberExecutionActor
- **Initialize**: Setup Cucumber test execution environment
- **StartTest**: Execute Cucumber scenarios
- **Technologies**: Cucumber JVM, Cucumber Scala

#### KafkaProducerActor
- **Initialize**: Configure Kafka producers with credentials
- **Technologies**: Alpakka Kafka, Kafka producer configuration

#### KafkaConsumerActor
- **Initialize**: Configure Kafka consumers with credentials
- **Technologies**: Alpakka Kafka, Kafka consumer configuration

---

## Implementation Statistics

### Code Metrics

| Actor | Lines of Code | Methods | Complexity |
|-------|--------------|---------|------------|
| BlockStorageActor | 340 | 12 | High (service integration complete) |
| VaultActor | 162 | 6 | Medium (service integration complete) |
| CucumberExecutionActor | 226 | 8 | Medium |
| KafkaProducerActor | 189 | 7 | Low |
| KafkaConsumerActor | 189 | 7 | Low |
| **TOTAL** | **1,106** | **40** | - |

### Pattern Compliance

- ✅ **Visibility Pattern**: All actors use `private[core]` object with public methods
- ✅ **Parent Reference Pattern**: All actors implement Akka Typed parent reference
- ✅ **Security Compliance**: 4 actors with security warning banners and log redaction
- ✅ **Exception Handling**: All actors bubble exceptions to parent
- ✅ **Factory Injection**: TestExecutionActor uses factory pattern for all children
- ✅ **Supervision**: All children supervised with restart strategy

### Testing Coverage

- **Unit Test Coverage**: 70%+ minimum requirement met
- **BDD Scenario Coverage**: All critical paths covered
- **Integration Coverage**: TestExecutionActor FSM scenarios test child coordination

---

## Related Documentation

- **Implementation Files**:
  - `test-probe-core/src/main/scala/com/company/probe/core/actors/BlockStorageActor.scala`
  - `test-probe-core/src/main/scala/com/company/probe/core/actors/VaultActor.scala`
  - `test-probe-core/src/main/scala/com/company/probe/core/actors/CucumberExecutionActor.scala`
  - `test-probe-core/src/main/scala/com/company/probe/core/actors/KafkaProducerActor.scala`
  - `test-probe-core/src/main/scala/com/company/probe/core/actors/KafkaConsumerActor.scala`

- **Test Files**:
  - Unit: `test-probe-core/src/test/scala/com/company/probe/core/actors/*ActorSpec.scala`
  - BDD: `test-probe-core/src/test/resources/features/component/child-actors/*.feature`
  - Steps: `test-probe-core/src/test/scala/com/company/probe/core/glue/steps/*ActorSteps.scala`

- **Planning Documents**:
  - `working/ChildActorsImplementationPlan.md` (Complete)
  - `working/childActorDefinitions.md` (Requirements)

- **Architecture Blueprints**:
  - [05.1 TestExecutionActor FSM](./05.1-test-execution-actor-fsm.md)
  - [05.2 TestExecutionActor Error Handling](./05.2-test-execution-actor-error-handling.md)

- **Architecture Decision Records**:
  - [ADR 004: Factory Injection for Child Actors](../../adr/004-factory-injection-for-child-actors.md)
  - [ADR 005: Error Kernel Pattern](../../adr/005-error-kernel-pattern.md)

---

## Document History

- 2025-10-20: Updated BlockStorageActor documentation with complete service integration details
- 2025-10-20: Documented pipeToSelf pattern, extracted handlers, state storage pattern
- 2025-10-20: Added service function integration (ServiceFunctionsContext pattern)
- 2025-10-20: Updated code metrics (340 lines, 12 methods, 20 tests)
- 2025-10-20: Added cross-references to service layer documentation and ADRs
- 2025-10-14: Initial blueprint created documenting all 5 completed child actors
- 2025-10-14: Added architecture diagrams (hierarchy, initialization, testing, shutdown)
- 2025-10-14: Documented parent reference pattern and security compliance
- 2025-10-14: Added complete testing statistics and service integration status
