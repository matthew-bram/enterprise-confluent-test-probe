# 06.1 REST API Triggers

**Last Updated:** 2025-11-26
**Status:** Active - Production-ready REST API operational
**Component:** REST API Trigger Layer
**Related Documents:**
- [06 Triggers Overview](06-triggers-overview.md)
- [03.1 REST API Architecture](../03%20APIs/03.1%20REST%20API/03.1-rest-api-architecture.md)
- [03.1 REST API Endpoints](../03%20APIs/03.1%20REST%20API/03.1-rest-api-endpoints.md)
- [ADR-REST-001: Error Handling Strategy](../../adr/ADR-REST-001-ERROR-HANDLING-STRATEGY.md)

---

## Table of Contents

- [Overview](#overview)
- [Request/Response Flow](#requestresponse-flow)
- [Endpoint Reference](#endpoint-reference)
- [Error Handling](#error-handling)
- [Rate Limiting Considerations](#rate-limiting-considerations)
- [Security Considerations](#security-considerations)
- [Integration Examples](#integration-examples)

---

## Overview

The REST API provides HTTP-based test execution triggers for the Test-Probe framework. Built on Apache Pekko HTTP 1.1.0, the API follows RESTful principles with asynchronous test execution via the actor system.

**Design Characteristics:**

1. **Accept-and-Queue**: HTTP request returns immediately (202 Accepted), test executes asynchronously
2. **Protocol Adapter**: Converts HTTP requests → Actor messages
3. **Resilient**: Circuit breaker pattern for fail-fast behavior
4. **Validated**: Early validation before actor communication
5. **Documented**: OpenAPI 3.0 specification available

**Key Features:**

| Feature | Implementation | Status |
|---------|---------------|--------|
| Test Initialization | POST `/api/v1/test/initialize` | ✅ Complete |
| Test Execution | POST `/api/v1/test/start` | ✅ Complete |
| Status Query | GET `/api/v1/test/{testId}/status` | ✅ Complete |
| Test Cancellation | POST `/api/v1/test/{testId}/cancel` | ✅ Complete |
| Queue Status | GET `/api/v1/queue` | ✅ Complete |
| Health Check | GET `/api/v1/health` | ✅ Complete |
| Error Handling | Custom handlers | ✅ Complete |
| Circuit Breaker | Fail-fast integration | ✅ Complete |

---

## Request/Response Flow

### High-Level Flow

```mermaid
sequenceDiagram
    participant C as HTTP Client<br/>(CI/CD Pipeline)
    participant RR as RestRoutes
    participant RV as RestValidation
    participant SIF as ServiceInterfaceFunctions
    participant CB as Circuit Breaker
    participant GA as GuardianActor
    participant QA as QueueActor

    C->>RR: POST /api/v1/test/start<br/>{test-id, bucket}
    RR->>RV: validateStartRequest(request)
    RV->>RR: Right() (validation passed)
    RR->>SIF: startTest(testId, bucket, testType)
    SIF->>CB: withCircuitBreaker { ... }
    CB->>GA: ask[StartTestResponse](StartTest(...))
    GA->>QA: EnqueueTest(testId, bucket, testType)
    QA->>GA: TestEnqueued(testId, position=1)
    GA->>CB: StartTestResponse(testId, accepted=true)
    CB->>SIF: Future[StartTestResponse]
    SIF->>RR: Future[StartTestResponse]
    RR->>C: 202 Accepted<br/>{test-id, accepted: true}

    Note over C: Client polls for status
    C->>RR: GET /api/v1/test/{testId}/status
    RR->>SIF: getStatus(testId)
    SIF->>GA: ask[TestStatusResponse](GetTestStatus(testId))
    GA->>SIF: TestStatusResponse(status="running")
    SIF->>RR: Future[TestStatusResponse]
    RR->>C: 200 OK<br/>{status: "running"}
```

---

### Error Flow

```mermaid
sequenceDiagram
    participant C as HTTP Client
    participant RR as RestRoutes
    participant EH as RestExceptionHandler
    participant SIF as ServiceInterfaceFunctions
    participant CB as Circuit Breaker

    C->>RR: POST /api/v1/test/start<br/>{invalid-data}
    RR->>RR: validateStartRequest(request)
    RR->>C: 400 Bad Request<br/>{error: "validation_error"}

    Note over C: Try again with valid data
    C->>RR: POST /api/v1/test/start<br/>{valid-data}
    RR->>SIF: startTest(testId, bucket, testType)
    SIF->>CB: withCircuitBreaker { ... }
    Note over CB: Circuit breaker open (too many failures)
    CB->>SIF: ServiceUnavailableException
    SIF->>EH: Handle exception
    EH->>C: 503 Service Unavailable<br/>{error: "service_unavailable"}
```

---

## Endpoint Reference

### POST /api/v1/test/initialize

**Purpose:** Generate new test ID for test execution

**Request:**
```http
POST /api/v1/test/initialize HTTP/1.1
Content-Type: application/json

{}
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "test-id": "abc-123-def-456",
  "message": "Test ID initialized successfully"
}
```

**Use Case:**
- Client doesn't have pre-assigned test ID
- Generate UUID server-side
- Simplifies client integration

---

### POST /api/v1/test/start

**Purpose:** Start test execution

**Request:**
```http
POST /api/v1/test/start HTTP/1.1
Content-Type: application/json

{
  "test-id": "abc-123-def-456",
  "block-storage-path": "s3://test-bucket/tests/abc-123",
  "test-type": "smoke"
}
```

**Request Fields:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `test-id` | UUID | Yes | Unique test identifier |
| `block-storage-path` | String | Yes | S3/Azure/GCS path to test data |
| `test-type` | String | No | Optional test type filter |

**Validation Rules:**
- `test-id`: Must be valid UUID format
- `block-storage-path`: Must start with `s3://`, `https://`, or `gs://`
- `test-type`: If provided, cannot be empty string

**Response (Success):**
```http
HTTP/1.1 202 Accepted
Content-Type: application/json

{
  "test-id": "abc-123-def-456",
  "accepted": true,
  "test-type": "smoke",
  "message": "Test queued for execution"
}
```

**Response (Validation Error):**
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "validation_error",
  "message": "Request validation failed",
  "details": "block-storage-path must be a valid S3 path (s3://bucket/...)",
  "timestamp": 1732626923000
}
```

**Response (Service Unavailable):**
```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/json

{
  "error": "service_unavailable",
  "message": "Circuit breaker open - too many failures",
  "retryAfter": "30s",
  "timestamp": 1732626923000
}
```

---

### GET /api/v1/test/{testId}/status

**Purpose:** Query test execution status

**Request:**
```http
GET /api/v1/test/abc-123/status HTTP/1.1
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "test-id": "abc-123",
  "status": "running",
  "current-state": "ExecutingTest",
  "message": "Test is currently executing"
}
```

**Status Values:**

| Status | Description |
|--------|-------------|
| `queued` | Test in queue, not started |
| `running` | Test execution in progress |
| `completed` | Test finished successfully |
| `failed` | Test execution failed |
| `cancelled` | Test cancelled by user |

**Current State Values:**

| State | Description |
|-------|-------------|
| `Idle` | TestExecutionActor created, waiting for start |
| `FetchingBlockStorage` | Downloading test data from S3/Azure/GCS |
| `FetchingVaultCredentials` | Retrieving Kafka OAuth credentials |
| `ConfiguringKafka` | Starting Kafka producers/consumers |
| `ExecutingTest` | Running Cucumber scenarios |
| `LoadingEvidence` | Uploading test evidence |
| `Completed` | Test finished |
| `Failed` | Test failed with error |

---

### POST /api/v1/test/{testId}/cancel

**Purpose:** Cancel running test

**Request:**
```http
POST /api/v1/test/abc-123/cancel HTTP/1.1
Content-Type: application/json

{}
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "test-id": "abc-123",
  "cancelled": true,
  "message": "Test cancellation requested"
}
```

**Response (Test Not Found):**
```http
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "test_not_found",
  "message": "No test found with ID: abc-123",
  "timestamp": 1732626923000
}
```

**Behavior:**
- Sends `CancelTest` message to TestExecutionActor
- Actor performs graceful shutdown (stop Kafka clients, cleanup resources)
- Test transitions to `Cancelled` state
- Evidence uploaded with cancellation metadata

---

### GET /api/v1/queue

**Purpose:** Query test queue status

**Request:**
```http
GET /api/v1/queue HTTP/1.1
```

**Response (Queue Status):**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "queue-size": 3,
  "queued-tests": [
    {"test-id": "test-1", "position": 1},
    {"test-id": "test-2", "position": 2},
    {"test-id": "test-3", "position": 3}
  ]
}
```

**Request (Specific Test Position):**
```http
GET /api/v1/queue?testId=test-2 HTTP/1.1
```

**Response (Test Position):**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "test-id": "test-2",
  "position": 2,
  "queue-size": 3
}
```

---

### GET /api/v1/health

**Purpose:** Health check for load balancers and monitoring

**Request:**
```http
GET /api/v1/health HTTP/1.1
```

**Response (Healthy):**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "healthy",
  "actor-system": "running",
  "timestamp": 1732626923000
}
```

**Response (Unhealthy):**
```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/json

{
  "status": "unhealthy",
  "actor-system": "unavailable",
  "timestamp": 1732626923000
}
```

**Health Check Logic:**
- Ping GuardianActor with `HealthCheck` message
- Timeout: 5 seconds
- Returns 200 OK if actor responds, 503 if timeout

---

## Error Handling

### Error Response Format (RFC 7807-Inspired)

```json
{
  "error": "error_code",
  "message": "Human-readable error message",
  "details": "Additional context (optional)",
  "timestamp": 1732626923000,
  "retryAfter": "30s"  // Optional, for 503 errors
}
```

---

### HTTP Status Codes

| Status Code | Error Type | Cause | Retry |
|------------|------------|-------|-------|
| **400 Bad Request** | `validation_error` | Invalid request format | No (fix request) |
| **404 Not Found** | `test_not_found` | Test ID doesn't exist | No |
| **422 Unprocessable Entity** | `invalid_state` | Test already completed | No |
| **503 Service Unavailable** | `service_unavailable` | Circuit breaker open | Yes (after 30s) |
| **504 Gateway Timeout** | `service_timeout` | Actor didn't respond in time | Yes (immediately) |

---

### Validation Errors

**Example: Empty Block Storage Path**
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "validation_error",
  "message": "Request validation failed",
  "details": "block-storage-path cannot be empty",
  "timestamp": 1732626923000
}
```

**Example: Invalid S3 Path**
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "validation_error",
  "message": "Request validation failed",
  "details": "block-storage-path must be a valid S3 path (s3://bucket/...)",
  "timestamp": 1732626923000
}
```

---

### Circuit Breaker Errors

**Example: Circuit Open**
```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/json

{
  "error": "service_unavailable",
  "message": "Circuit breaker open - too many failures",
  "retryAfter": "30s",
  "timestamp": 1732626923000
}
```

**Circuit Breaker States:**

| State | Behavior | Response |
|-------|----------|----------|
| **Closed** | Normal operation | Request processed |
| **Open** | Too many failures (5+) | 503 Service Unavailable |
| **Half-Open** | Testing recovery | 1 request allowed |

**Configuration:**
```hocon
circuit-breaker {
  max-failures = 5
  call-timeout = 25.seconds
  reset-timeout = 30.seconds
}
```

**Reference:** [03.1 REST Timeouts & Resilience](../03%20APIs/03.1%20REST%20API/03.1-rest-timeouts-resilience.md)

---

## Rate Limiting Considerations

### Current Status

**Rate limiting is NOT implemented** in the current version. The system relies on:

1. **FIFO Queue**: QueueActor processes tests sequentially
2. **Circuit Breaker**: Fails fast when system overloaded
3. **Backpressure**: Pekko HTTP handles backpressure automatically

---

### Future Rate Limiting Design

**Token Bucket Algorithm (Planned):**

```scala
// Per-client rate limiting
val rateLimiter = RateLimiter(
  capacity = 100,      // 100 requests
  refillRate = 10,     // 10 requests/second
  refillPeriod = 1.second
)

// Apply to routes
path("api" / "v1" / "test" / "start") {
  extractClientIP { clientIp =>
    rateLimiter.checkLimit(clientIp) match {
      case Allowed =>
        // Process request
      case Denied =>
        complete(StatusCodes.TooManyRequests, "Rate limit exceeded")
    }
  }
}
```

**Rate Limit Response:**
```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 10

{
  "error": "rate_limit_exceeded",
  "message": "Too many requests",
  "retryAfter": "10s",
  "timestamp": 1732626923000
}
```

**Reference:** [ADR-REST-002: Validation Pattern](../../adr/ADR-REST-002-VALIDATION-PATTERN.md)

---

## Security Considerations

### Authentication (Future)

**Current:** No authentication (trusted internal network)

**Planned:**
- OAuth 2.0 / JWT bearer tokens
- API keys for service-to-service
- mTLS for enterprise deployments

**Example (OAuth):**
```http
POST /api/v1/test/start HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "test-id": "abc-123",
  "block-storage-path": "s3://test-bucket/tests/abc-123"
}
```

---

### Authorization (Future)

**RBAC Model:**

| Role | Permissions |
|------|-------------|
| `test-executor` | Start tests, query status |
| `test-admin` | Cancel tests, view queue |
| `system-admin` | All permissions + health check |

**Example:**
```json
{
  "sub": "ci-pipeline",
  "roles": ["test-executor"],
  "permissions": ["test.start", "test.status"]
}
```

---

### Input Validation

**Current Implementation:**

```scala
object RestValidation {
  def validateStartRequest(req: RestStartTestRequest): Either[String, Unit] = {
    val path = req.`block-storage-path`.trim

    if (path.isEmpty) {
      Left("block-storage-path cannot be empty")
    } else if (!path.startsWith("s3://") && !path.startsWith("https://") && !path.startsWith("gs://")) {
      Left("block-storage-path must be a valid cloud storage path")
    } else {
      req.`test-type` match {
        case Some(testType) if testType.trim.isEmpty =>
          Left("test-type cannot be empty string")
        case _ =>
          Right(())
      }
    }
  }
}
```

**Validation Properties:**
- Early validation (before actor communication)
- Clear error messages (field-specific)
- Fail-fast (return immediately on invalid input)
- Composable (Either monad)

---

## Integration Examples

### CI/CD Pipeline Integration (GitHub Actions)

```yaml
name: Run Test-Probe Tests

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Initialize Test ID
        id: init
        run: |
          TEST_ID=$(curl -X POST http://test-probe.company.com/api/v1/test/initialize | jq -r '.["test-id"]')
          echo "test_id=$TEST_ID" >> $GITHUB_OUTPUT

      - name: Upload Test Data to S3
        run: |
          aws s3 cp ./tests s3://test-bucket/tests/${{ steps.init.outputs.test_id }} --recursive

      - name: Start Test Execution
        run: |
          curl -X POST http://test-probe.company.com/api/v1/test/start \
            -H "Content-Type: application/json" \
            -d '{
              "test-id": "${{ steps.init.outputs.test_id }}",
              "block-storage-path": "s3://test-bucket/tests/${{ steps.init.outputs.test_id }}",
              "test-type": "smoke"
            }'

      - name: Wait for Test Completion
        run: |
          while true; do
            STATUS=$(curl http://test-probe.company.com/api/v1/test/${{ steps.init.outputs.test_id }}/status | jq -r '.status')
            if [ "$STATUS" = "completed" ]; then
              echo "Test completed successfully"
              exit 0
            elif [ "$STATUS" = "failed" ]; then
              echo "Test failed"
              exit 1
            fi
            sleep 10
          done
```

---

### Jenkins Pipeline Integration

```groovy
pipeline {
  agent any
  stages {
    stage('Initialize Test') {
      steps {
        script {
          def response = httpRequest(
            url: 'http://test-probe.company.com/api/v1/test/initialize',
            httpMode: 'POST',
            contentType: 'APPLICATION_JSON'
          )
          env.TEST_ID = readJSON(text: response.content).'test-id'
        }
      }
    }

    stage('Upload Test Data') {
      steps {
        sh "aws s3 cp ./tests s3://test-bucket/tests/${env.TEST_ID} --recursive"
      }
    }

    stage('Execute Test') {
      steps {
        httpRequest(
          url: 'http://test-probe.company.com/api/v1/test/start',
          httpMode: 'POST',
          contentType: 'APPLICATION_JSON',
          requestBody: """
            {
              "test-id": "${env.TEST_ID}",
              "block-storage-path": "s3://test-bucket/tests/${env.TEST_ID}",
              "test-type": "regression"
            }
          """
        )
      }
    }

    stage('Wait for Completion') {
      steps {
        script {
          while (true) {
            def response = httpRequest(
              url: "http://test-probe.company.com/api/v1/test/${env.TEST_ID}/status",
              httpMode: 'GET'
            )
            def status = readJSON(text: response.content).status
            if (status == 'completed') {
              echo 'Test completed successfully'
              break
            } else if (status == 'failed') {
              error 'Test failed'
            }
            sleep 10
          }
        }
      }
    }
  }
}
```

---

### curl Examples

**Initialize Test:**
```bash
curl -X POST http://localhost:8080/api/v1/test/initialize
```

**Start Test:**
```bash
curl -X POST http://localhost:8080/api/v1/test/start \
  -H "Content-Type: application/json" \
  -d '{
    "test-id": "abc-123",
    "block-storage-path": "s3://test-bucket/tests/abc-123",
    "test-type": "smoke"
  }'
```

**Query Status:**
```bash
curl http://localhost:8080/api/v1/test/abc-123/status
```

**Cancel Test:**
```bash
curl -X POST http://localhost:8080/api/v1/test/abc-123/cancel
```

**Query Queue:**
```bash
curl http://localhost:8080/api/v1/queue
curl http://localhost:8080/api/v1/queue?testId=abc-123
```

**Health Check:**
```bash
curl http://localhost:8080/api/v1/health
```

---

## Related Documents

**Architecture:**
- [06 Triggers Overview](06-triggers-overview.md)
- [03.1 REST API Architecture](../03%20APIs/03.1%20REST%20API/03.1-rest-api-architecture.md)
- [03.1 REST API Endpoints](../03%20APIs/03.1%20REST%20API/03.1-rest-api-endpoints.md)
- [03.1 REST Error Handling](../03%20APIs/03.1%20REST%20API/03.1-rest-error-handling.md)

**ADRs:**
- [ADR-REST-001: Error Handling Strategy](../../adr/ADR-REST-001-ERROR-HANDLING-STRATEGY.md)
- [ADR-REST-002: Validation Pattern](../../adr/ADR-REST-002-VALIDATION-PATTERN.md)
- [ADR-REST-003: Pekko HTTP Technology](../../adr/ADR-REST-003-PEKKO-HTTP-TECHNOLOGY.md)

**API Specification:**
- [OpenAPI 3.0 Specification](../../../api/rest-api-openapi-specification.md)

---

**Last Updated:** 2025-11-26
**Status:** Active - Production-ready REST API operational
