# Example application.conf for Rosetta Template Variable Substitution
#
# This file demonstrates the config values required to support the
# Rosetta YAML template examples in this directory.
#
# IMPORTANT: All config paths referenced in Rosetta templates MUST be
# under the "request-params" namespace for security validation.
#
# See: RequestBodyBuilder.scala (lines 67-88) for security validation rules

# =============================================================================
# Request Parameters Namespace (REQUIRED for security validation)
# =============================================================================
request-params {

  # Vault request configuration
  vault-requests {

    # MF Team configuration (mf-team-complex-vault.yaml)
    mf-team {
      # Azure AD application ID for MF team's vault access
      client-app-id = "MF-PROD-CONSUMER-APP-123"
      client-app-id = ${?MF_TEAM_CLIENT_APP_ID}  # Override from env var

      # Organization ID for MF team
      org-id = "ORG-MF-PRODUCTION-456"
      org-id = ${?MF_TEAM_ORG_ID}  # Override from env var
    }

    # Team A configuration (mixed-sources-example.yaml)
    team-a {
      # Team identifier
      id = "team-a-prod-789"
      id = ${?TEAM_A_ID}  # Override from env var
    }

    # Environment identifier (used across multiple templates)
    environment = "production"
    environment = ${?DEPLOYMENT_ENVIRONMENT}  # Override from env var
  }

  # Additional vault configuration examples
  # Add more teams/configurations as needed:
  #
  # vault-requests {
  #   team-b {
  #     client-app-id = "TEAM-B-APP-ID"
  #     region = "us-west-2"
  #   }
  #
  #   hip-team {
  #     # hip-team-simple-vault.yaml doesn't need static config
  #     # It only uses {{clientPrincipal}} from TopicDirective
  #   }
  # }
}

# =============================================================================
# Template Variable Pattern Examples
# =============================================================================
#
# Rosetta templates support THREE variable patterns:
#
# 1. Config Path: {{$^request-params.path.to.value}}
#    - Resolves from this application.conf file
#    - MUST start with "request-params." prefix (security requirement)
#    - Uses RequestBodyBuilder.resolveConfigPath()
#    - Example: "{{$^request-params.vault-requests.mf-team.client-app-id}}"
#               -> "MF-PROD-CONSUMER-APP-123"
#
# 2. Metadata Key: {{'metadataKey'}}
#    - Resolves from TopicDirective.metadata Map (single quotes)
#    - Populated from block storage YAML during BlockStorageService phase
#    - Uses RequestBodyBuilder.resolveMetadataKey()
#    - Example: "{{'blood-type'}}" -> "O-negative"
#
# 3. Directive Field: {{fieldName}}
#    - Resolves from TopicDirective built-in fields (no quotes, no prefix)
#    - Available fields: topic, role, clientPrincipal
#    - Uses RequestBodyBuilder.resolveDirectiveField()
#    - Example: "{{clientPrincipal}}" -> "team-a-principal"
#
# =============================================================================

# =============================================================================
# Security Validation
# =============================================================================
#
# RequestBodyBuilder enforces security rules on config path references:
#
# ✅ VALID:   {{$^request-params.vault-requests.team.id}}
# ✅ VALID:   {{$^request-params.my-app.setting}}
# ❌ INVALID: {{$^database.password}}              (missing request-params prefix)
# ❌ INVALID: {{$^request-params.}}                (no subpath after prefix)
# ❌ INVALID: {{$^request-params.bad$char}}        (invalid characters)
#
# Allowed characters in config paths: a-z A-Z 0-9 . _ -
#
# See: RequestBodyBuilder.scala:67-88 (validateConfigPath method)
# =============================================================================

# =============================================================================
# Example Usage Flow
# =============================================================================
#
# 1. BlockStorageService loads test specification from S3/Azure:
#    - Extracts metadata: test-run-id, correlation-id, blood-type, etc.
#    - Creates TopicDirective with metadata Map
#
# 2. VaultService receives TopicDirective:
#    TopicDirective(
#      topic = "mf-team-1-topic",
#      role = "CONSUMER",
#      clientPrincipal = "team-a-principal",
#      metadata = Map(
#        "blood-type" -> "O-negative",
#        "test-run-id" -> "run-123"
#      )
#    )
#
# 3. RosettaConfig loaded from vault-mapping-rosetta.yaml:
#    request-template:
#      auth:
#        credentials:
#          clientPrincipal: "{{clientPrincipal}}"
#          client-application-id: "{{$^request-params.vault-requests.mf-team.client-app-id}}"
#        resource:
#          blood-type: "{{'blood-type'}}"
#
# 4. RequestBodyBuilder.build() substitutes variables:
#    {
#      "auth": {
#        "credentials": {
#          "clientPrincipal": "team-a-principal",           (from TopicDirective.clientPrincipal)
#          "client-application-id": "MF-PROD-CONSUMER-APP-123" (from this config file)
#        },
#        "resource": {
#          "blood-type": "O-negative"                       (from TopicDirective.metadata)
#        }
#      }
#    }
#
# 5. AzureVaultService POSTs JSON to Azure Function
#
# 6. Response mapped via VaultCredentialsMapper using Rosetta mappings
#
# 7. JaasConfigBuilder creates JAAS config for Kafka
#
# 8. KafkaSecurityDirective returned to TestExecutionActor
#
# =============================================================================
